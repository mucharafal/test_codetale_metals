[{
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "typo: `TaskMemoryManager`",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-13T03:05:02Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that",
    "line": 30
  }, {
    "author": {
      "login": "tejasapatil"
    },
    "body": "I think keeping it public would be more performant VS mutating the field using a method. I know that this using method is better way in terms of design but there are places in codebase where we do this for solely for perf. reasons\r\n",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-13T03:05:09Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that",
    "line": 30
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "@tejasapatil While we make it private, accessors (`setPageNumber` and `getPageNumber`) has `final` attribute. Thus, JIT compiler will [inline](https://techblug.wordpress.com/2013/08/19/java-jit-compiler-inlining/) these methods.  \r\nAs a result, I think that this version with `final` accessors can achieve the similar performance compared to the approach with `public` fields.\r\n\r\nWhat do you think? If you have strong recommendation, I am OK to make it `public`.\r\n\r\nBTW, Thank you for pointing my typo. I will fix typo soon.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-13T03:19:10Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that",
    "line": 30
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "wrong import order",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-28T22:20:11Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "thanks, fixed",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-29T17:01:00Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "we need some document about it. Now we have the general `MemoryBlock` abstraction, do we still need to expose the `baseObj` and `baseOffset` concept?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-28T22:23:23Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = -1;\n+  private int pageNumber = -1;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "BTW if we really need to expose them, shall we expose `MemoryLocation` instead?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-28T22:32:35Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = -1;\n+  private int pageNumber = -1;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Sounds reasonable. Should we still need `MemoryLocation` to expose a logical memory location?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-02T07:59:11Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = -1;\n+  private int pageNumber = -1;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {"
  }, {
    "author": {
      "login": "Ngone51"
    },
    "body": "Maybe we can treat ```MemoryLocation``` as an attribute variable for ```MemoryBlock``` rather than to ```extends``` it.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-03T07:48:40Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = -1;\n+  private int pageNumber = -1;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {"
  }, {
    "author": {
      "login": "Ngone51"
    },
    "body": ">@Ngone51 could you please elaborate on your idea about MemoryLocation while we do not have MemoryLocation now? I think that it would be good to have a final method for getBaseObject for performance.\r\n\r\nHi, @kiszk. Actually, this is a comment follow the discussion between @cloud-fan & @viirya :\r\n\r\n> @cloud-fan : we need some document about it. Now we have the general MemoryBlock abstraction, do we still need to expose the baseObj and baseOffset concept?\r\n@cloud-fan : BTW if we really need to expose them, shall we expose MemoryLocation instead?\r\n@viirya Sounds reasonable. Should we still need MemoryLocation to expose a logical memory location?\r\n\r\n（I have no idea why those comments hide）\r\n\r\nAnd my suggestion is something like:\r\n```\r\npublic abstract class MemoryBlock {\r\n  MemoryLocation location;\r\n  ...\r\n}\r\n```\r\nrather than the original path:\r\n```\r\npublic class MemoryBlock extends MemoryLocation {\r\n  ...\r\n}\r\n```",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-03T14:46:18Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = -1;\n+  private int pageNumber = -1;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why these are static methods?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-28T22:25:50Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = -1;\n+  private int pageNumber = -1;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public abstract Object getObjectVolatile(long offset);\n+\n+  public abstract void putObjectVolatile(long offset, Object value);\n+\n+  public static final void copyMemory("
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "`copyMemory` has two kinds of arguments: `src` and `dst`.  \r\nIf we make them non-static method, it is not easy to understand whether `this` is `src` or `dst`. If we keep method name `MemoryBlock.copy`, I think that it is good to keep current form (it is common in `memcpy`).\r\n\r\nOr, can we prepare two methods `MemoryBlock.copyFrom(srcOffset, dst...)` and `MemoryBlock.copyTo(src..., dstOffset)`.\r\n\r\n@cloud-fan What do you think?\r\n",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-29T08:13:29Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = -1;\n+  private int pageNumber = -1;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public abstract Object getObjectVolatile(long offset);\n+\n+  public abstract void putObjectVolatile(long offset, Object value);\n+\n+  public static final void copyMemory("
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "It's weird to have this interface. I think `MemoryAllocator` is the right place to do it.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-28T22:40:20Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = -1;\n+  private int pageNumber = -1;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I think that an issue is the name of this method. This `allocate()` method does not allocate actual memory region while `MemoryAllocator.allocate()` allocate a memory region.  This `allocate()` method just allocates a `MemoryBlock()`.\r\nHow about renaming `MemoryBlock.allocate()` to `MemoryBlock.allocateMemoryBlock()` instead of moving this to `MemoryAllocator`?\r\n\r\n@cloud-fan What do you think?\r\n",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-29T05:45:28Z",
    "diffHunk": "@@ -17,47 +17,168 @@\n \n package org.apache.spark.unsafe.memory;\n \n-import javax.annotation.Nullable;\n-\n import org.apache.spark.unsafe.Platform;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes .\n  */\n-public class MemoryBlock extends MemoryLocation {\n+public abstract class MemoryBlock {\n+  @Nullable\n+  protected final Object obj;\n \n-  private final long length;\n+  protected final long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = -1;\n+  private int pageNumber = -1;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "`A representation of a consecutive memory block in Spark. It defines the common interfaces for memory accessing and mutating.`",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-22T14:59:49Z",
    "diffHunk": "@@ -22,10 +22,9 @@\n import org.apache.spark.unsafe.Platform;\n \n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes ."
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Thanks, done",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-23T16:22:01Z",
    "diffHunk": "@@ -22,10 +22,9 @@\n import org.apache.spark.unsafe.Platform;\n \n /**\n- * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ * A declaration of interfaces of MemoryBlock classes ."
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "What should we expect the offset to be? Ideally I think we should assume the beginning offset of this memory block is 0, and concrete implementations should adjust by adding `Platform.BYTE_ARRAY_OFFSET` or something accordingly.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-22T15:02:41Z",
    "diffHunk": "@@ -45,38 +44,149 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "Looks like now we ask the caller side to add `MemoryBlock.baseOffset` themselves, I think we should not leave this to the caller side. ",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-22T15:11:13Z",
    "diffHunk": "@@ -45,38 +44,149 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Yeah, this is a part where we should clean up. This is derived from the conventional usage.\r\nLet me think about this cleanup.\r\nProbably, I will address later commits in this PR.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-22T19:31:26Z",
    "diffHunk": "@@ -45,38 +44,149 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I removed `MemoryBlock.baseOffset` at caller of `MemoryBlock.copyMemory`, `allocate`, `copyFrom`, and `writeTo`. However, I realized that it is not easy to remove `MemoryBlock.baseOffset` at caller of `getXXX` or `putXXX`.  \r\nI will address them in another PR.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-25T12:21:39Z",
    "diffHunk": "@@ -45,38 +44,149 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "hopefully the API would look like other data classes like `InternalRow` and `ColumnVector`, i.e. `getInt(int index)` and `putInt(int index, int value)`.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-26T06:46:45Z",
    "diffHunk": "@@ -45,38 +44,149 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "do we really need this?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-22T15:04:12Z",
    "diffHunk": "@@ -45,38 +44,149 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public abstract Object getObjectVolatile(long offset);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Since Spark doe not use `xxxObjectVolatile`, we can remove them.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-22T15:34:13Z",
    "diffHunk": "@@ -45,38 +44,149 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public abstract Object getObjectVolatile(long offset);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Yeah, dropped",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-23T16:22:17Z",
    "diffHunk": "@@ -45,38 +44,149 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public abstract Object getObjectVolatile(long offset);"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "2 thoughts:\r\n1. How much benefit can we get by making this method abstract? Is it as significant as other methods like `getInt`?\r\n2. How much benefit can we get by having so many varieties? What if we just have one `copyFrom(Object src, long srcOffset, ...)`?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-22T15:09:29Z",
    "diffHunk": "@@ -45,38 +44,149 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public abstract Object getObjectVolatile(long offset);\n+\n+  public abstract void putObjectVolatile(long offset, Object value);\n+\n+  public static void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), srcOffset, dst.getBaseObject(), dstOffset, length);\n+  }\n+\n+  public abstract void copyFrom(byte[] src, long srcOffset, long dstOffset, long length);"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I hope this decision is data-driven, i.e. we prove that there is no perf benefit to either have varieties of `copyFrom`, or make all implementations have `copyFrom`.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-26T06:45:36Z",
    "diffHunk": "@@ -45,38 +45,135 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+            dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);\n+  }\n+\n+  public static final void copyMemory(MemoryBlock src, MemoryBlock dst, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset(),\n+      dst.getBaseObject(), dst.getBaseOffset(), length);\n+  }\n+\n+  public final void copyFrom(Object src, long srcOffset, long dstOffset, long length) {",
    "line": 181
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I see. I already confirmed there is no performance difference between `Object -> Object`, `byte[] -> byte[]`.  \r\n\r\nI will check performance in cases `Object -> byte[]`, `Object -> short[]`, `Object -> int[]`, `Object -> long[]`, `Object -> float[]`, and `Object -> double[]`.  \r\nIs this what you suggested?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-26T07:29:52Z",
    "diffHunk": "@@ -45,38 +45,135 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+            dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);\n+  }\n+\n+  public static final void copyMemory(MemoryBlock src, MemoryBlock dst, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset(),\n+      dst.getBaseObject(), dst.getBaseOffset(), length);\n+  }\n+\n+  public final void copyFrom(Object src, long srcOffset, long dstOffset, long length) {",
    "line": 181
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "I think it's enough, make sure the benchmark in the PR description can still get the same speed up :)",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-26T07:32:36Z",
    "diffHunk": "@@ -45,38 +45,135 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+            dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);\n+  }\n+\n+  public static final void copyMemory(MemoryBlock src, MemoryBlock dst, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset(),\n+      dst.getBaseObject(), dst.getBaseOffset(), length);\n+  }\n+\n+  public final void copyFrom(Object src, long srcOffset, long dstOffset, long length) {",
    "line": 181
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Sure, I will put the previous results and upcoming results in the PR description. ",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-26T08:27:04Z",
    "diffHunk": "@@ -45,38 +45,135 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+            dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);\n+  }\n+\n+  public static final void copyMemory(MemoryBlock src, MemoryBlock dst, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset(),\n+      dst.getBaseObject(), dst.getBaseOffset(), length);\n+  }\n+\n+  public final void copyFrom(Object src, long srcOffset, long dstOffset, long length) {",
    "line": 181
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I added performance comparison results in the PR description as a decision point.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-26T18:20:00Z",
    "diffHunk": "@@ -45,38 +45,135 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size\n+   */\n+  public abstract MemoryBlock allocate(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+            dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);\n+  }\n+\n+  public static final void copyMemory(MemoryBlock src, MemoryBlock dst, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset(),\n+      dst.getBaseObject(), dst.getBaseOffset(), length);\n+  }\n+\n+  public final void copyFrom(Object src, long srcOffset, long dstOffset, long length) {",
    "line": 181
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "`allocate` is not a good name as this is the projection-like API, how about `subBlock`?\r\n\r\nWe should mention that the actual data is not copied or moved, we just created a new view of the data.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-01T15:03:26Z",
    "diffHunk": "@@ -45,38 +45,135 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Instantiate the same type of MemoryBlock with new offset and size"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Should we define the behavior when `offset` is invalid here? E.g., out of range?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-02T08:02:28Z",
    "diffHunk": "@@ -45,38 +45,136 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied.\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);",
    "line": 164
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I see. I will put a comment since these operations do not guarantee behavior if `offset` is invalid.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-02T09:38:02Z",
    "diffHunk": "@@ -45,38 +45,136 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied.\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);",
    "line": 164
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Should we check if this copy is valid?\r\n\r\nE.g., srcOffset + length > src.size() or dstOffset + length > dst.size()?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-02T08:06:26Z",
    "diffHunk": "@@ -45,38 +45,136 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied.\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+      dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "The condition depends on whether `MemoryBlock` is `OffHeapMemoryBlock`. Since the condition of this check is not simple, I gave up adding assertion due to performance.\r\n\r\ni.e. `srcOffset + length > src.size() or dstOffset + length > dst.size()` works except `OffHeapMemoryBlock`.\r\n",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-02T09:41:06Z",
    "diffHunk": "@@ -45,38 +45,136 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied.\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+      dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Check if `length <= src.size()` and `length <= dst.size()`?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-02T08:07:20Z",
    "diffHunk": "@@ -45,38 +45,136 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied.\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+      dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);\n+  }\n+\n+  public static final void copyMemory(MemoryBlock src, MemoryBlock dst, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset(),\n+      dst.getBaseObject(), dst.getBaseOffset(), length);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "This assertion can be reasonably simple.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-02T09:41:41Z",
    "diffHunk": "@@ -45,38 +45,136 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied.\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+      dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);\n+  }\n+\n+  public static final void copyMemory(MemoryBlock src, MemoryBlock dst, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset(),\n+      dst.getBaseObject(), dst.getBaseOffset(), length);"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "ditto.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-02T08:07:41Z",
    "diffHunk": "@@ -45,38 +45,136 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied.\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+      dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);\n+  }\n+\n+  public static final void copyMemory(MemoryBlock src, MemoryBlock dst, long length) {\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset(),\n+      dst.getBaseObject(), dst.getBaseOffset(), length);\n+  }\n+\n+  public final void copyFrom(Object src, long srcOffset, long dstOffset, long length) {\n+    Platform.copyMemory(src, srcOffset, obj, offset + dstOffset, length);\n+  }\n+\n+  public final void writeTo(long srcOffset, Object dst, long dstOffset, long length) {\n+    Platform.copyMemory(obj, offset + srcOffset, dst, dstOffset, length);"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "Ngone51"
    },
    "body": "For more details:\r\n ```\"Instantiate MemoryBlock for type \" + obj.getClass() + \" is not supported now.\"```\r\nWDYT?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-03T07:35:04Z",
    "diffHunk": "@@ -45,38 +45,143 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Thanks, I will add more words",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-03T12:20:26Z",
    "diffHunk": "@@ -45,38 +45,143 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n   public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  public MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(obj.getClass() + \" is not supported now\");"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Do we still need static version of `copyMemory`? I think users can always use `subBlock` and the non-static `copyFrom/writeTo`",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-19T22:21:07Z",
    "diffHunk": "@@ -45,38 +45,159 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n-  public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+  protected MemoryBlock(@Nullable Object obj, long offset, long length) {\n+    if (offset < 0 || length < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Length \" + length + \" and offset \" + offset + \"must be non-negative\");\n+    }\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  protected MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(\n+        \"Instantiate MemoryBlock for type \" + obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied. If parameters are invalid, an exception is thrown\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+  protected void checkSubBlockRange(long offset, long size) {\n+    if (this.offset + offset < 0 || size < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Size \" + size + \" and offset \" + (this.offset + offset) + \" must be non-negative\");\n+    }\n+    if (offset + size > length) {\n+      throw new ArrayIndexOutOfBoundsException(\"The sum of size \" + size + \" and offset \" +\n+        offset + \" should not be larger than the length \" + length + \" in the MemoryBlock\");\n+    }\n+  }\n+\n+  /**\n+   * getXXX/putXXX does not ensure guarantee behavior if the offset is invalid. e.g  cause illegal\n+   * memory access, throw an exception, or etc.\n+   */\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    assert(length <= src.length && length <= dst.length);\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+      dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);\n+  }\n+\n+  public static final void copyMemory(MemoryBlock src, MemoryBlock dst, long length) {",
    "line": 175
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "[Some methods](https://github.com/apache/spark/pull/19222/files#diff-4ff36e9e54fd26f5b1441e877c8187dfR107) relate to `reallocate` still call this method.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-20T17:51:33Z",
    "diffHunk": "@@ -45,38 +45,159 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected final long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n-  public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+  protected MemoryBlock(@Nullable Object obj, long offset, long length) {\n+    if (offset < 0 || length < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Length \" + length + \" and offset \" + offset + \"must be non-negative\");\n+    }\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  protected MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(\n+        \"Instantiate MemoryBlock for type \" + obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied. If parameters are invalid, an exception is thrown\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+  protected void checkSubBlockRange(long offset, long size) {\n+    if (this.offset + offset < 0 || size < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Size \" + size + \" and offset \" + (this.offset + offset) + \" must be non-negative\");\n+    }\n+    if (offset + size > length) {\n+      throw new ArrayIndexOutOfBoundsException(\"The sum of size \" + size + \" and offset \" +\n+        offset + \" should not be larger than the length \" + length + \" in the MemoryBlock\");\n+    }\n+  }\n+\n+  /**\n+   * getXXX/putXXX does not ensure guarantee behavior if the offset is invalid. e.g  cause illegal\n+   * memory access, throw an exception, or etc.\n+   */\n+  public abstract int getInt(long offset);\n+\n+  public abstract void putInt(long offset, int value);\n+\n+  public abstract boolean getBoolean(long offset);\n+\n+  public abstract void putBoolean(long offset, boolean value);\n+\n+  public abstract byte getByte(long offset);\n+\n+  public abstract void putByte(long offset, byte value);\n+\n+  public abstract short getShort(long offset);\n+\n+  public abstract void putShort(long offset, short value);\n+\n+  public abstract long getLong(long offset);\n+\n+  public abstract void putLong(long offset, long value);\n+\n+  public abstract float getFloat(long offset);\n+\n+  public abstract void putFloat(long offset, float value);\n+\n+  public abstract double getDouble(long offset);\n+\n+  public abstract void putDouble(long offset, double value);\n+\n+  public static final void copyMemory(\n+      MemoryBlock src, long srcOffset, MemoryBlock dst, long dstOffset, long length) {\n+    assert(length <= src.length && length <= dst.length);\n+    Platform.copyMemory(src.getBaseObject(), src.getBaseOffset() + srcOffset,\n+      dst.getBaseObject(), dst.getBaseOffset() + dstOffset, length);\n+  }\n+\n+  public static final void copyMemory(MemoryBlock src, MemoryBlock dst, long length) {",
    "line": 175
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "We should clearly document what's the expectation of the `offset` parameter, i.e. an index based on `this.getBaseOffset`.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-26T05:49:31Z",
    "diffHunk": "@@ -45,38 +45,159 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n-  public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+  protected MemoryBlock(@Nullable Object obj, long offset, long length) {\n+    if (offset < 0 || length < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Length \" + length + \" and offset \" + offset + \"must be non-negative\");\n+    }\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  protected MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(\n+        \"Instantiate MemoryBlock for type \" + obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied. If parameters are invalid, an exception is thrown\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+  protected void checkSubBlockRange(long offset, long size) {\n+    if (this.offset + offset < 0 || size < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Size \" + size + \" and offset \" + (this.offset + offset) + \" must be non-negative\");\n+    }\n+    if (offset + size > length) {\n+      throw new ArrayIndexOutOfBoundsException(\"The sum of size \" + size + \" and offset \" +\n+        offset + \" should not be larger than the length \" + length + \" in the MemoryBlock\");\n+    }\n+  }\n+\n+  /**\n+   * getXXX/putXXX does not ensure guarantee behavior if the offset is invalid. e.g  cause illegal\n+   * memory access, throw an exception, or etc.\n+   */\n+  public abstract int getInt(long offset);"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "BTW do you have a list of followup JIRAs? If you are the only one working on it, I'm fine to change the semantics of the offset later. Otherwise I'd like to make it right at the first version, i.e. 0-based offset.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-26T05:53:17Z",
    "diffHunk": "@@ -45,38 +45,159 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n-  public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+  protected MemoryBlock(@Nullable Object obj, long offset, long length) {\n+    if (offset < 0 || length < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Length \" + length + \" and offset \" + offset + \"must be non-negative\");\n+    }\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  protected MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(\n+        \"Instantiate MemoryBlock for type \" + obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied. If parameters are invalid, an exception is thrown\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+  protected void checkSubBlockRange(long offset, long size) {\n+    if (this.offset + offset < 0 || size < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Size \" + size + \" and offset \" + (this.offset + offset) + \" must be non-negative\");\n+    }\n+    if (offset + size > length) {\n+      throw new ArrayIndexOutOfBoundsException(\"The sum of size \" + size + \" and offset \" +\n+        offset + \" should not be larger than the length \" + length + \" in the MemoryBlock\");\n+    }\n+  }\n+\n+  /**\n+   * getXXX/putXXX does not ensure guarantee behavior if the offset is invalid. e.g  cause illegal\n+   * memory access, throw an exception, or etc.\n+   */\n+  public abstract int getInt(long offset);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "If we work for `0-based offset`, I think that we may need to update additional many files. This is because many files include hard-coded offset such as `Platform.BYTE_ARRAY_OFFSET`. In particular, the generated code uses the hard-coded offset.\r\nI think that it seems to very hard and buggy work to make it right with introducing `MemoryBlock` at the first version.\r\n\r\nCan we prepare two version `getInt()` (0-based offset) and `getIntOffset()` (current semantics)? Then, we first use `getIntOffset()`. In the following JIRAs, we are incrementally change from `getIntOffset()` to `getInt()`? WDYT?\r\n\r\n\r\nBTW, Here is a list of followup JIRAs that I have already worked:\r\n- SPARK-23779, #20890, [WIP]TaskMemoryManager and UnsafeSorter related classes use MemoryBlock\r\n- SPARK-23762, #20871, [WIP]UTF8StringBuffer uses MemoryBlock\r\n- SPARK-22246, #19472, [WIP]Improve performance of UnsafeRow, UnsafeArrayData, UnsafeMapData, and SpecificUnsafeRowJoiner by using MemoryBlock\r\n- SPARK-23763, #20874, [WIP]OffHeapColumnVector uses MemoryBlock \r\n\r\nThese PRs do not use `0-based offset` yet.\r\n",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-26T06:42:55Z",
    "diffHunk": "@@ -45,38 +45,159 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n-  public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+  protected MemoryBlock(@Nullable Object obj, long offset, long length) {\n+    if (offset < 0 || length < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Length \" + length + \" and offset \" + offset + \"must be non-negative\");\n+    }\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  protected MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(\n+        \"Instantiate MemoryBlock for type \" + obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied. If parameters are invalid, an exception is thrown\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+  protected void checkSubBlockRange(long offset, long size) {\n+    if (this.offset + offset < 0 || size < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Size \" + size + \" and offset \" + (this.offset + offset) + \" must be non-negative\");\n+    }\n+    if (offset + size > length) {\n+      throw new ArrayIndexOutOfBoundsException(\"The sum of size \" + size + \" and offset \" +\n+        offset + \" should not be larger than the length \" + length + \" in the MemoryBlock\");\n+    }\n+  }\n+\n+  /**\n+   * getXXX/putXXX does not ensure guarantee behavior if the offset is invalid. e.g  cause illegal\n+   * memory access, throw an exception, or etc.\n+   */\n+  public abstract int getInt(long offset);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "@cloud-fan After prototyping, I succeeded to make `UTF8String` right in this PR.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-26T20:06:22Z",
    "diffHunk": "@@ -45,38 +45,159 @@\n    */\n   public static final int FREED_IN_ALLOCATOR_PAGE_NUMBER = -3;\n \n-  private final long length;\n+  @Nullable\n+  protected Object obj;\n+\n+  protected long offset;\n+\n+  protected long length;\n \n   /**\n    * Optional page number; used when this MemoryBlock represents a page allocated by a\n-   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\n-   * which lives in a different package.\n+   * TaskMemoryManager. This field can be updated using setPageNumber method so that\n+   * this can be modified by the TaskMemoryManager, which lives in a different package.\n    */\n-  public int pageNumber = NO_PAGE_NUMBER;\n+  private int pageNumber = NO_PAGE_NUMBER;\n \n-  public MemoryBlock(@Nullable Object obj, long offset, long length) {\n-    super(obj, offset);\n+  protected MemoryBlock(@Nullable Object obj, long offset, long length) {\n+    if (offset < 0 || length < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Length \" + length + \" and offset \" + offset + \"must be non-negative\");\n+    }\n+    this.obj = obj;\n+    this.offset = offset;\n     this.length = length;\n   }\n \n+  protected MemoryBlock() {\n+    this(null, 0, 0);\n+  }\n+\n+  public final Object getBaseObject() {\n+    return obj;\n+  }\n+\n+  public final long getBaseOffset() {\n+    return offset;\n+  }\n+\n+  public void resetObjAndOffset() {\n+    this.obj = null;\n+    this.offset = 0;\n+  }\n+\n   /**\n    * Returns the size of the memory block.\n    */\n-  public long size() {\n+  public final long size() {\n     return length;\n   }\n \n-  /**\n-   * Creates a memory block pointing to the memory used by the long array.\n-   */\n-  public static MemoryBlock fromLongArray(final long[] array) {\n-    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n+  public final void setPageNumber(int pageNum) {\n+    pageNumber = pageNum;\n+  }\n+\n+  public final int getPageNumber() {\n+    return pageNumber;\n   }\n \n   /**\n    * Fills the memory block with the specified byte value.\n    */\n-  public void fill(byte value) {\n+  public final void fill(byte value) {\n     Platform.setMemory(obj, offset, length, value);\n   }\n+\n+  /**\n+   * Instantiate MemoryBlock for given object type with new offset\n+   */\n+  public final static MemoryBlock allocateFromObject(Object obj, long offset, long length) {\n+    MemoryBlock mb = null;\n+    if (obj instanceof byte[]) {\n+      byte[] array = (byte[])obj;\n+      mb = new ByteArrayMemoryBlock(array, offset, length);\n+    } else if (obj instanceof long[]) {\n+      long[] array = (long[])obj;\n+      mb = new OnHeapMemoryBlock(array, offset, length);\n+    } else if (obj == null) {\n+      // we assume that to pass null pointer means off-heap\n+      mb = new OffHeapMemoryBlock(offset, length);\n+    } else {\n+      throw new UnsupportedOperationException(\n+        \"Instantiate MemoryBlock for type \" + obj.getClass() + \" is not supported now\");\n+    }\n+    return mb;\n+  }\n+\n+  /**\n+   * Just instantiate the same type of MemoryBlock with new offset and size. The data is not\n+   * copied. If parameters are invalid, an exception is thrown\n+   */\n+  public abstract MemoryBlock subBlock(long offset, long size);\n+\n+  protected void checkSubBlockRange(long offset, long size) {\n+    if (this.offset + offset < 0 || size < 0) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        \"Size \" + size + \" and offset \" + (this.offset + offset) + \" must be non-negative\");\n+    }\n+    if (offset + size > length) {\n+      throw new ArrayIndexOutOfBoundsException(\"The sum of size \" + size + \" and offset \" +\n+        offset + \" should not be larger than the length \" + length + \" in the MemoryBlock\");\n+    }\n+  }\n+\n+  /**\n+   * getXXX/putXXX does not ensure guarantee behavior if the offset is invalid. e.g  cause illegal\n+   * memory access, throw an exception, or etc.\n+   */\n+  public abstract int getInt(long offset);"
  }],
  "prId": 19222
}]