[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "?",
    "commit": "da93837805efc76c83511eed6a71d49851b34945",
    "createdAt": "2019-11-15T18:16:43Z",
    "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle.protocol;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+import org.apache.spark.network.protocol.Encoders;\n+\n+import java.util.*;\n+import java.util.Map.Entry;\n+\n+// Needed by ScalaDoc. See SPARK-7726",
    "line": 27
  }],
  "prId": 25299
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I prefer using `Map.Entry` to importing the nested type.",
    "commit": "da93837805efc76c83511eed6a71d49851b34945",
    "createdAt": "2019-11-15T18:19:40Z",
    "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle.protocol;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+import org.apache.spark.network.protocol.Encoders;\n+\n+import java.util.*;\n+import java.util.Map.Entry;\n+\n+// Needed by ScalaDoc. See SPARK-7726\n+\n+\n+/** The reply to get local dirs giving back the dirs for each of the requested executors. */\n+public class LocalDirsForExecutors extends BlockTransferMessage {\n+  private final String[] execIds;\n+  private final int[] numLocalDirsByExec;\n+  private final String[] allLocalDirs;\n+\n+  public LocalDirsForExecutors(Map<String, String[]> localDirsByExec) {\n+    this.execIds = new String[localDirsByExec.size()];\n+    this.numLocalDirsByExec = new int[localDirsByExec.size()];\n+    ArrayList<String> localDirs = new ArrayList<>();\n+    int index = 0;\n+    for (Entry<String, String[]> e: localDirsByExec.entrySet()) {"
  }],
  "prId": 25299
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`new String[localDirs.length]`",
    "commit": "da93837805efc76c83511eed6a71d49851b34945",
    "createdAt": "2019-11-15T18:20:17Z",
    "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle.protocol;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+import org.apache.spark.network.protocol.Encoders;\n+\n+import java.util.*;\n+import java.util.Map.Entry;\n+\n+// Needed by ScalaDoc. See SPARK-7726\n+\n+\n+/** The reply to get local dirs giving back the dirs for each of the requested executors. */\n+public class LocalDirsForExecutors extends BlockTransferMessage {\n+  private final String[] execIds;\n+  private final int[] numLocalDirsByExec;\n+  private final String[] allLocalDirs;\n+\n+  public LocalDirsForExecutors(Map<String, String[]> localDirsByExec) {\n+    this.execIds = new String[localDirsByExec.size()];\n+    this.numLocalDirsByExec = new int[localDirsByExec.size()];\n+    ArrayList<String> localDirs = new ArrayList<>();\n+    int index = 0;\n+    for (Entry<String, String[]> e: localDirsByExec.entrySet()) {\n+      execIds[index] = e.getKey();\n+      numLocalDirsByExec[index] = e.getValue().length;\n+      Collections.addAll(localDirs, e.getValue());\n+      index++;\n+    }\n+    this.allLocalDirs = localDirs.toArray(new String[0]);",
    "line": 47
  }, {
    "author": {
      "login": "attilapiros"
    },
    "body": "The `new String[localDirs.length]` will be a String array with the length of `localDirs.length` but all the item will be `null`. On the other hand `localDirs.toArray(new String[0])` will be filled with values of the `localDirs` array list. \r\n",
    "commit": "da93837805efc76c83511eed6a71d49851b34945",
    "createdAt": "2019-11-15T20:16:55Z",
    "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle.protocol;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+import org.apache.spark.network.protocol.Encoders;\n+\n+import java.util.*;\n+import java.util.Map.Entry;\n+\n+// Needed by ScalaDoc. See SPARK-7726\n+\n+\n+/** The reply to get local dirs giving back the dirs for each of the requested executors. */\n+public class LocalDirsForExecutors extends BlockTransferMessage {\n+  private final String[] execIds;\n+  private final int[] numLocalDirsByExec;\n+  private final String[] allLocalDirs;\n+\n+  public LocalDirsForExecutors(Map<String, String[]> localDirsByExec) {\n+    this.execIds = new String[localDirsByExec.size()];\n+    this.numLocalDirsByExec = new int[localDirsByExec.size()];\n+    ArrayList<String> localDirs = new ArrayList<>();\n+    int index = 0;\n+    for (Entry<String, String[]> e: localDirsByExec.entrySet()) {\n+      execIds[index] = e.getKey();\n+      numLocalDirsByExec[index] = e.getValue().length;\n+      Collections.addAll(localDirs, e.getValue());\n+      index++;\n+    }\n+    this.allLocalDirs = localDirs.toArray(new String[0]);",
    "line": 47
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Read the javadoc for `toArray`.",
    "commit": "da93837805efc76c83511eed6a71d49851b34945",
    "createdAt": "2019-11-15T20:25:08Z",
    "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle.protocol;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+import org.apache.spark.network.protocol.Encoders;\n+\n+import java.util.*;\n+import java.util.Map.Entry;\n+\n+// Needed by ScalaDoc. See SPARK-7726\n+\n+\n+/** The reply to get local dirs giving back the dirs for each of the requested executors. */\n+public class LocalDirsForExecutors extends BlockTransferMessage {\n+  private final String[] execIds;\n+  private final int[] numLocalDirsByExec;\n+  private final String[] allLocalDirs;\n+\n+  public LocalDirsForExecutors(Map<String, String[]> localDirsByExec) {\n+    this.execIds = new String[localDirsByExec.size()];\n+    this.numLocalDirsByExec = new int[localDirsByExec.size()];\n+    ArrayList<String> localDirs = new ArrayList<>();\n+    int index = 0;\n+    for (Entry<String, String[]> e: localDirsByExec.entrySet()) {\n+      execIds[index] = e.getKey();\n+      numLocalDirsByExec[index] = e.getValue().length;\n+      Collections.addAll(localDirs, e.getValue());\n+      index++;\n+    }\n+    this.allLocalDirs = localDirs.toArray(new String[0]);",
    "line": 47
  }, {
    "author": {
      "login": "attilapiros"
    },
    "body": "I know what toArray does, but I misunderstood your comment. Now I know what you meant. \r\n",
    "commit": "da93837805efc76c83511eed6a71d49851b34945",
    "createdAt": "2019-11-15T20:44:08Z",
    "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle.protocol;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+import org.apache.spark.network.protocol.Encoders;\n+\n+import java.util.*;\n+import java.util.Map.Entry;\n+\n+// Needed by ScalaDoc. See SPARK-7726\n+\n+\n+/** The reply to get local dirs giving back the dirs for each of the requested executors. */\n+public class LocalDirsForExecutors extends BlockTransferMessage {\n+  private final String[] execIds;\n+  private final int[] numLocalDirsByExec;\n+  private final String[] allLocalDirs;\n+\n+  public LocalDirsForExecutors(Map<String, String[]> localDirsByExec) {\n+    this.execIds = new String[localDirsByExec.size()];\n+    this.numLocalDirsByExec = new int[localDirsByExec.size()];\n+    ArrayList<String> localDirs = new ArrayList<>();\n+    int index = 0;\n+    for (Entry<String, String[]> e: localDirsByExec.entrySet()) {\n+      execIds[index] = e.getKey();\n+      numLocalDirsByExec[index] = e.getValue().length;\n+      Collections.addAll(localDirs, e.getValue());\n+      index++;\n+    }\n+    this.allLocalDirs = localDirs.toArray(new String[0]);",
    "line": 47
  }, {
    "author": {
      "login": "attilapiros"
    },
    "body": "I changed it locally then IntelliJ suggested to change it back to an empty array, so I read after a bit and they say calling it with empty array can be more effective:\r\n\r\n> Bottom line: toArray(new T[0]) seems faster, safer, and contractually cleaner, and therefore should be the default choice now. Future VM optimizations may close this performance gap for toArray(new T[size]), rendering the current \"believed to be optimal\" usages on par with an actually optimal one. Further improvements in toArray APIs would follow the same logic as toArray(new T[0]) — the collection itself should create the appropriate storage.\r\n\r\nhttps://shipilev.net/blog/2016/arrays-wisdom-ancients/\r\n",
    "commit": "da93837805efc76c83511eed6a71d49851b34945",
    "createdAt": "2019-11-18T18:20:42Z",
    "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle.protocol;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+import org.apache.spark.network.protocol.Encoders;\n+\n+import java.util.*;\n+import java.util.Map.Entry;\n+\n+// Needed by ScalaDoc. See SPARK-7726\n+\n+\n+/** The reply to get local dirs giving back the dirs for each of the requested executors. */\n+public class LocalDirsForExecutors extends BlockTransferMessage {\n+  private final String[] execIds;\n+  private final int[] numLocalDirsByExec;\n+  private final String[] allLocalDirs;\n+\n+  public LocalDirsForExecutors(Map<String, String[]> localDirsByExec) {\n+    this.execIds = new String[localDirsByExec.size()];\n+    this.numLocalDirsByExec = new int[localDirsByExec.size()];\n+    ArrayList<String> localDirs = new ArrayList<>();\n+    int index = 0;\n+    for (Entry<String, String[]> e: localDirsByExec.entrySet()) {\n+      execIds[index] = e.getKey();\n+      numLocalDirsByExec[index] = e.getValue().length;\n+      Collections.addAll(localDirs, e.getValue());\n+      index++;\n+    }\n+    this.allLocalDirs = localDirs.toArray(new String[0]);",
    "line": 47
  }],
  "prId": 25299
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: too many spaces",
    "commit": "da93837805efc76c83511eed6a71d49851b34945",
    "createdAt": "2019-11-21T23:14:18Z",
    "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle.protocol;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+import org.apache.spark.network.protocol.Encoders;\n+\n+import java.util.*;\n+\n+// Needed by ScalaDoc. See SPARK-7726\n+import static org.apache.spark.network.shuffle.protocol.BlockTransferMessage.Type;\n+\n+/** The reply to get local dirs giving back the dirs for each of the requested executors. */\n+public class LocalDirsForExecutors extends BlockTransferMessage {\n+  private final String[] execIds;\n+  private final int[] numLocalDirsByExec;\n+  private final String[] allLocalDirs;\n+\n+  public LocalDirsForExecutors(Map<String, String[]> localDirsByExec) {\n+    this.execIds = new String[localDirsByExec.size()];\n+    this.numLocalDirsByExec = new int[localDirsByExec.size()];\n+    ArrayList<String> localDirs = new ArrayList<>();\n+    int index = 0;\n+    for (Map.Entry<String, String[]> e: localDirsByExec.entrySet()) {\n+      execIds[index] = e.getKey();\n+      numLocalDirsByExec[index] = e.getValue().length;\n+      Collections.addAll(localDirs, e.getValue());\n+      index++;\n+    }\n+    this.allLocalDirs = localDirs.toArray(new String[0]);\n+  }\n+\n+  private LocalDirsForExecutors(String[] execIds, int[] numLocalDirsByExec, String[] allLocalDirs) {\n+    this.execIds = execIds;\n+    this.numLocalDirsByExec = numLocalDirsByExec;\n+    this.allLocalDirs = allLocalDirs;\n+  }\n+\n+  @Override\n+  protected Type type() { return Type.LOCAL_DIRS_FOR_EXECUTORS; }\n+\n+  @Override\n+  public int hashCode() {\n+    return Arrays.hashCode(execIds);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return Objects.toStringHelper(this)\n+      .add(\"execIds\", Arrays.toString(execIds))\n+      .add(\"numLocalDirsByExec\", Arrays.toString(numLocalDirsByExec))\n+      .add(\"allLocalDirs\", Arrays.toString(allLocalDirs))\n+      .toString();\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    if (other instanceof LocalDirsForExecutors) {\n+      LocalDirsForExecutors o = (LocalDirsForExecutors) other;\n+      return Arrays.equals(execIds, o.execIds)\n+        && Arrays.equals(numLocalDirsByExec, o.numLocalDirsByExec)\n+        && Arrays.equals(allLocalDirs, o.allLocalDirs);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public int encodedLength() {\n+    return Encoders.StringArrays.encodedLength(execIds)\n+      + Encoders.IntArrays.encodedLength(numLocalDirsByExec)\n+      + Encoders.StringArrays.encodedLength(allLocalDirs);\n+  }\n+\n+  @Override\n+  public void encode(ByteBuf buf) {\n+    Encoders.StringArrays.encode(buf, execIds);\n+    Encoders.IntArrays.encode(buf, numLocalDirsByExec);\n+    Encoders.StringArrays.encode(buf, allLocalDirs);\n+  }\n+\n+  public static LocalDirsForExecutors decode(ByteBuf buf) {\n+    String[] execIds = Encoders.StringArrays.decode(buf);\n+    int[] numLocalDirsByExec = Encoders.IntArrays.decode(buf);\n+    String[] allLocalDirs = Encoders.StringArrays.decode(buf);\n+    return new LocalDirsForExecutors(execIds, numLocalDirsByExec, allLocalDirs);\n+  }\n+\n+  public Map<String, String[]> getLocalDirsByExec() {\n+    Map<String, String[]> localDirsByExec = new HashMap<>();\n+    int index = 0;\n+    int localDirsIndex = 0;\n+    for (int length: numLocalDirsByExec) {\n+      localDirsByExec.put(execIds[index],\n+        Arrays.copyOfRange(allLocalDirs, localDirsIndex, localDirsIndex + length));\n+      localDirsIndex += length;\n+      index++;\n+    }\n+    return  localDirsByExec;"
  }],
  "prId": 25299
}]