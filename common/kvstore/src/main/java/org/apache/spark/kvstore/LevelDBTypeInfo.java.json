[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "one thing I had some trouble keeping straight as I read through this was the difference between an index \"key\" and an index \"value\".  Normally i think of \"value\" as what you are calling \"data\" here.  It seems like you are calling the index value just final component \"+key1\", while the key refers to the entire thing \"Foo __main__ +key1\".  \r\n\r\nIs that right?\r\n\r\nIt might also help adding comments on `entityKey()` and `getValue()` as well",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-06-01T15:33:50Z",
    "diffHunk": "@@ -0,0 +1,502 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Holds metadata about app-specific types stored in LevelDB. Serves as a cache for data collected\n+ * via reflection, to make it cheaper to access it multiple times.\n+ *\n+ * <p>\n+ * The hierarchy of keys stored in LevelDB looks roughly like the following. This hierarchy ensures\n+ * that iteration over indices is easy, and that updating values in the store is not overly\n+ * expensive. Of note, indices choose using more disk space (one value per key) instead of keeping\n+ * lists of pointers, which would be more expensive to update at runtime.\n+ * </p>\n+ *\n+ * <p>\n+ * Indentation defines when a sub-key lives under a parent key. In LevelDB, this means the full\n+ * key would be the concatenation of everything up to that point in the hierarchy, with each\n+ * component separated by a NULL byte.\n+ * </p>\n+ *\n+ * <pre>\n+ * +TYPE_NAME\n+ *   NATURAL_INDEX\n+ *     +NATURAL_KEY\n+ *     -\n+ *   -NATURAL_INDEX\n+ *   INDEX_NAME\n+ *     +INDEX_VALUE\n+ *       +NATURAL_KEY\n+ *     -INDEX_VALUE\n+ *     .INDEX_VALUE\n+ *       CHILD_INDEX_NAME\n+ *         +CHILD_INDEX_VALUE\n+ *           NATURAL_KEY_OR_DATA\n+ *         -\n+ *   -INDEX_NAME\n+ * </pre>\n+ *\n+ * <p>\n+ * Entity data (either the entity's natural key or a copy of the data) is stored in all keys\n+ * that end with \"+<something>\". A count of all objects that match a particular top-level index\n+ * value is kept at the end marker (\"-<something>\"). A count is also kept at the natural index's end\n+ * marker, to make it easy to retrieve the number of all elements of a particular type.\n+ * </p>\n+ *\n+ * <p>\n+ * To illustrate, given a type \"Foo\", with a natural index and a second index called \"bar\", you'd\n+ * have these keys and values in the store for two instances, one with natural key \"key1\" and the\n+ * other \"key2\", both with value \"yes\" for \"bar\":\n+ * </p>\n+ *\n+ * <pre>\n+ * Foo __main__ +key1   [data for instance 1]\n+ * Foo __main__ +key2   [data for instance 2]",
    "line": 84
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Yeah, it's a little confusing because I try to only call \"key\" the full key in LevelDB. Let me look at the comments and try to make them consistent, at least.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-06-01T19:58:20Z",
    "diffHunk": "@@ -0,0 +1,502 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Holds metadata about app-specific types stored in LevelDB. Serves as a cache for data collected\n+ * via reflection, to make it cheaper to access it multiple times.\n+ *\n+ * <p>\n+ * The hierarchy of keys stored in LevelDB looks roughly like the following. This hierarchy ensures\n+ * that iteration over indices is easy, and that updating values in the store is not overly\n+ * expensive. Of note, indices choose using more disk space (one value per key) instead of keeping\n+ * lists of pointers, which would be more expensive to update at runtime.\n+ * </p>\n+ *\n+ * <p>\n+ * Indentation defines when a sub-key lives under a parent key. In LevelDB, this means the full\n+ * key would be the concatenation of everything up to that point in the hierarchy, with each\n+ * component separated by a NULL byte.\n+ * </p>\n+ *\n+ * <pre>\n+ * +TYPE_NAME\n+ *   NATURAL_INDEX\n+ *     +NATURAL_KEY\n+ *     -\n+ *   -NATURAL_INDEX\n+ *   INDEX_NAME\n+ *     +INDEX_VALUE\n+ *       +NATURAL_KEY\n+ *     -INDEX_VALUE\n+ *     .INDEX_VALUE\n+ *       CHILD_INDEX_NAME\n+ *         +CHILD_INDEX_VALUE\n+ *           NATURAL_KEY_OR_DATA\n+ *         -\n+ *   -INDEX_NAME\n+ * </pre>\n+ *\n+ * <p>\n+ * Entity data (either the entity's natural key or a copy of the data) is stored in all keys\n+ * that end with \"+<something>\". A count of all objects that match a particular top-level index\n+ * value is kept at the end marker (\"-<something>\"). A count is also kept at the natural index's end\n+ * marker, to make it easy to retrieve the number of all elements of a particular type.\n+ * </p>\n+ *\n+ * <p>\n+ * To illustrate, given a type \"Foo\", with a natural index and a second index called \"bar\", you'd\n+ * have these keys and values in the store for two instances, one with natural key \"key1\" and the\n+ * other \"key2\", both with value \"yes\" for \"bar\":\n+ * </p>\n+ *\n+ * <pre>\n+ * Foo __main__ +key1   [data for instance 1]\n+ * Foo __main__ +key2   [data for instance 2]",
    "line": 84
  }],
  "prId": 17902
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "I had some trouble understanding this part at first, I couldn't understand why the values would differ -- now that I understand I see you had explained it in this last part of the comment.  I think it might have been easier for me to follow if you add the `existing` is the element that was previously stored in the *natural index* at the same key as the new entity, I had lost track of that detail when I was reading this code by itself.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-06-01T15:42:26Z",
    "diffHunk": "@@ -0,0 +1,502 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Holds metadata about app-specific types stored in LevelDB. Serves as a cache for data collected\n+ * via reflection, to make it cheaper to access it multiple times.\n+ *\n+ * <p>\n+ * The hierarchy of keys stored in LevelDB looks roughly like the following. This hierarchy ensures\n+ * that iteration over indices is easy, and that updating values in the store is not overly\n+ * expensive. Of note, indices choose using more disk space (one value per key) instead of keeping\n+ * lists of pointers, which would be more expensive to update at runtime.\n+ * </p>\n+ *\n+ * <p>\n+ * Indentation defines when a sub-key lives under a parent key. In LevelDB, this means the full\n+ * key would be the concatenation of everything up to that point in the hierarchy, with each\n+ * component separated by a NULL byte.\n+ * </p>\n+ *\n+ * <pre>\n+ * +TYPE_NAME\n+ *   NATURAL_INDEX\n+ *     +NATURAL_KEY\n+ *     -\n+ *   -NATURAL_INDEX\n+ *   INDEX_NAME\n+ *     +INDEX_VALUE\n+ *       +NATURAL_KEY\n+ *     -INDEX_VALUE\n+ *     .INDEX_VALUE\n+ *       CHILD_INDEX_NAME\n+ *         +CHILD_INDEX_VALUE\n+ *           NATURAL_KEY_OR_DATA\n+ *         -\n+ *   -INDEX_NAME\n+ * </pre>\n+ *\n+ * <p>\n+ * Entity data (either the entity's natural key or a copy of the data) is stored in all keys\n+ * that end with \"+<something>\". A count of all objects that match a particular top-level index\n+ * value is kept at the end marker (\"-<something>\"). A count is also kept at the natural index's end\n+ * marker, to make it easy to retrieve the number of all elements of a particular type.\n+ * </p>\n+ *\n+ * <p>\n+ * To illustrate, given a type \"Foo\", with a natural index and a second index called \"bar\", you'd\n+ * have these keys and values in the store for two instances, one with natural key \"key1\" and the\n+ * other \"key2\", both with value \"yes\" for \"bar\":\n+ * </p>\n+ *\n+ * <pre>\n+ * Foo __main__ +key1   [data for instance 1]\n+ * Foo __main__ +key2   [data for instance 2]\n+ * Foo __main__ -       [count of all Foo]\n+ * Foo bar +yes +key1   [instance 1 key or data, depending on index type]\n+ * Foo bar +yes +key2   [instance 2 key or data, depending on index type]\n+ * Foo bar +yes -       [count of all Foo with \"bar=yes\" ]\n+ * </pre>\n+ *\n+ * <p>\n+ * Note that all indexed values are prepended with \"+\", even if the index itself does not have an\n+ * explicit end marker. This allows for easily skipping to the end of an index by telling LevelDB\n+ * to seek to the \"phantom\" end marker of the index.\n+ * </p>\n+ *\n+ * <p>\n+ * Child indices are stored after their parent index. In the example above, let's assume there is\n+ * a child index \"child\", whose parent is \"bar\". If both instances have value \"no\" for this field,\n+ * the data in the store would look something like the following:\n+ * </p>\n+ *\n+ * <pre>\n+ * ...\n+ * Foo bar +yes -\n+ * Foo bar .yes .child +no +key1   [instance 1 key or data, depending on index type]\n+ * Foo bar .yes .child +no +key2   [instance 2 key or data, depending on index type]\n+ * ...\n+ * </pre>\n+ */\n+class LevelDBTypeInfo {\n+\n+  static final byte[] END_MARKER = new byte[] { '-' };\n+  static final byte ENTRY_PREFIX = (byte) '+';\n+  static final byte KEY_SEPARATOR = 0x0;\n+  static byte TRUE = (byte) '1';\n+  static byte FALSE = (byte) '0';\n+\n+  private static final byte SECONDARY_IDX_PREFIX = (byte) '.';\n+  private static final byte POSITIVE_MARKER = (byte) '=';\n+  private static final byte NEGATIVE_MARKER = (byte) '*';\n+  private static final byte[] HEX_BYTES = new byte[] {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n+  };\n+\n+  private final LevelDB db;\n+  private final Class<?> type;\n+  private final Map<String, Index> indices;\n+  private final byte[] typePrefix;\n+\n+  LevelDBTypeInfo(LevelDB db, Class<?> type, byte[] alias) throws Exception {\n+    this.db = db;\n+    this.type = type;\n+    this.indices = new HashMap<>();\n+\n+    KVTypeInfo ti = new KVTypeInfo(type);\n+\n+    // First create the parent indices, then the child indices.\n+    ti.indices().forEach(idx -> {\n+      if (idx.parent().isEmpty()) {\n+        indices.put(idx.value(), new Index(idx, ti.getAccessor(idx.value()), null));\n+      }\n+    });\n+    ti.indices().forEach(idx -> {\n+      if (!idx.parent().isEmpty()) {\n+        indices.put(idx.value(), new Index(idx, ti.getAccessor(idx.value()),\n+          indices.get(idx.parent())));\n+      }\n+    });\n+\n+    this.typePrefix = alias;\n+  }\n+\n+  Class<?> type() {\n+    return type;\n+  }\n+\n+  byte[] keyPrefix() {\n+    return typePrefix;\n+  }\n+\n+  Index naturalIndex() {\n+    return index(KVIndex.NATURAL_INDEX_NAME);\n+  }\n+\n+  Index index(String name) {\n+    Index i = indices.get(name);\n+    Preconditions.checkArgument(i != null, \"Index %s does not exist for type %s.\", name,\n+      type.getName());\n+    return i;\n+  }\n+\n+  Collection<Index> indices() {\n+    return indices.values();\n+  }\n+\n+  byte[] buildKey(byte[]... components) {\n+    return buildKey(true, components);\n+  }\n+\n+  byte[] buildKey(boolean addTypePrefix, byte[]... components) {\n+    int len = 0;\n+    if (addTypePrefix) {\n+      len += typePrefix.length + 1;\n+    }\n+    for (byte[] comp : components) {\n+      len += comp.length;\n+    }\n+    len += components.length - 1;\n+\n+    byte[] dest = new byte[len];\n+    int written = 0;\n+\n+    if (addTypePrefix) {\n+      System.arraycopy(typePrefix, 0, dest, 0, typePrefix.length);\n+      dest[typePrefix.length] = KEY_SEPARATOR;\n+      written += typePrefix.length + 1;\n+    }\n+\n+    for (byte[] comp : components) {\n+      System.arraycopy(comp, 0, dest, written, comp.length);\n+      written += comp.length;\n+      if (written < dest.length) {\n+        dest[written] = KEY_SEPARATOR;\n+        written++;\n+      }\n+    }\n+\n+    return dest;\n+  }\n+\n+  /**\n+   * Models a single index in LevelDB. See top-level class's javadoc for a description of how the\n+   * keys are generated.\n+   */\n+  class Index {\n+\n+    private final boolean copy;\n+    private final boolean isNatural;\n+    private final byte[] name;\n+    private final KVTypeInfo.Accessor accessor;\n+    private final Index parent;\n+\n+    private Index(KVIndex self, KVTypeInfo.Accessor accessor, Index parent) {\n+      byte[] name = self.value().getBytes(UTF_8);\n+      if (parent != null) {\n+        byte[] child = new byte[name.length + 1];\n+        child[0] = SECONDARY_IDX_PREFIX;\n+        System.arraycopy(name, 0, child, 1, name.length);\n+      }\n+\n+      this.name = name;\n+      this.isNatural = self.value().equals(KVIndex.NATURAL_INDEX_NAME);\n+      this.copy = isNatural || self.copy();\n+      this.accessor = accessor;\n+      this.parent = parent;\n+    }\n+\n+    boolean isCopy() {\n+      return copy;\n+    }\n+\n+    boolean isChild() {\n+      return parent != null;\n+    }\n+\n+    Index parent() {\n+      return parent;\n+    }\n+\n+    /**\n+     * Creates a key prefix for child indices of this index. This allows the prefix to be\n+     * calculated only once, avoiding redundant work when multiple child indices of the\n+     * same parent index exist.\n+     */\n+    byte[] childPrefix(Object value) throws Exception {\n+      Preconditions.checkState(parent == null, \"Not a parent index.\");\n+      return buildKey(name, toParentKey(value));\n+    }\n+\n+    Object getValue(Object entity) throws Exception {\n+      return accessor.get(entity);\n+    }\n+\n+    private void checkParent(byte[] prefix) {\n+      if (prefix != null) {\n+        Preconditions.checkState(parent != null, \"Parent prefix provided for parent index.\");\n+      } else {\n+        Preconditions.checkState(parent == null, \"Parent prefix missing for child index.\");\n+      }\n+    }\n+\n+    /** The prefix for all keys that belong to this index. */\n+    byte[] keyPrefix(byte[] prefix) {\n+      checkParent(prefix);\n+      return (parent != null) ? buildKey(false, prefix, name) : buildKey(name);\n+    }\n+\n+    /** The key where to start ascending iteration for entries that match the given value. */\n+    byte[] start(byte[] prefix, Object value) {\n+      checkParent(prefix);\n+      return (parent != null) ? buildKey(false, prefix, name, toKey(value))\n+        : buildKey(name, toKey(value));\n+    }\n+\n+    /** The key for the index's end marker. */\n+    byte[] end(byte[] prefix) {\n+      checkParent(prefix);\n+      return (parent != null) ? buildKey(false, prefix, name, END_MARKER)\n+        : buildKey(name, END_MARKER);\n+    }\n+\n+    /** The key for the end marker for index entries with the given value. */\n+    byte[] end(byte[] prefix, Object value) throws Exception {\n+      checkParent(prefix);\n+      return (parent != null) ? buildKey(false, prefix, name, toKey(value), END_MARKER)\n+        : buildKey(name, toKey(value), END_MARKER);\n+    }\n+\n+    /** The key in the index that identifies the given entity. */\n+    byte[] entityKey(byte[] prefix, Object entity) throws Exception {\n+      Object indexValue = getValue(entity);\n+      Preconditions.checkNotNull(indexValue, \"Null index value for %s in type %s.\",\n+        name, type.getName());\n+      byte[] entityKey = start(prefix, indexValue);\n+      if (!isNatural) {\n+        entityKey = buildKey(false, entityKey, toKey(naturalIndex().getValue(entity)));\n+      }\n+      return entityKey;\n+    }\n+\n+    private void updateCount(WriteBatch batch, byte[] key, long delta) throws Exception {\n+      long updated = getCount(key) + delta;\n+      if (updated > 0) {\n+        batch.put(key, db.serializer.serialize(updated));\n+      } else {\n+        batch.delete(key);\n+      }\n+    }\n+\n+    private void addOrRemove(\n+        WriteBatch batch,\n+        Object entity,\n+        Object existing,\n+        byte[] data,\n+        byte[] naturalKey,\n+        byte[] prefix) throws Exception {\n+      Object indexValue = getValue(entity);\n+      Preconditions.checkNotNull(indexValue, \"Null index value for %s in type %s.\",\n+        name, type.getName());\n+\n+      byte[] entityKey = start(prefix, indexValue);\n+      if (!isNatural) {\n+        entityKey = buildKey(false, entityKey, naturalKey);\n+      }\n+\n+      boolean needCountUpdate = (existing == null);\n+\n+      // Check whether the index key for the existing value matches the new value. If it doesn't,\n+      // then explicitly delete the existing key, otherwise just let the \"put()\" call overwrite it.\n+      //\n+      // Also check whether we need to update the counts. If the indexed value is changing, we\n+      // need to decrement the count at the old index value, and the new indexed value count needs\n+      // to be incremented.\n+      //\n+      // Natural indices don't need to be checked, because by definition both old and new elements\n+      // will have the same key."
  }],
  "prId": 17902
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "since `key1` is already in key, why we still need to put `key` in the value region?",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-09-26T14:55:03Z",
    "diffHunk": "@@ -0,0 +1,516 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Holds metadata about app-specific types stored in LevelDB. Serves as a cache for data collected\n+ * via reflection, to make it cheaper to access it multiple times.\n+ *\n+ * <p>\n+ * The hierarchy of keys stored in LevelDB looks roughly like the following. This hierarchy ensures\n+ * that iteration over indices is easy, and that updating values in the store is not overly\n+ * expensive. Of note, indices choose using more disk space (one value per key) instead of keeping\n+ * lists of pointers, which would be more expensive to update at runtime.\n+ * </p>\n+ *\n+ * <p>\n+ * Indentation defines when a sub-key lives under a parent key. In LevelDB, this means the full\n+ * key would be the concatenation of everything up to that point in the hierarchy, with each\n+ * component separated by a NULL byte.\n+ * </p>\n+ *\n+ * <pre>\n+ * +TYPE_NAME\n+ *   NATURAL_INDEX\n+ *     +NATURAL_KEY\n+ *     -\n+ *   -NATURAL_INDEX\n+ *   INDEX_NAME\n+ *     +INDEX_VALUE\n+ *       +NATURAL_KEY\n+ *     -INDEX_VALUE\n+ *     .INDEX_VALUE\n+ *       CHILD_INDEX_NAME\n+ *         +CHILD_INDEX_VALUE\n+ *           NATURAL_KEY_OR_DATA\n+ *         -\n+ *   -INDEX_NAME\n+ * </pre>\n+ *\n+ * <p>\n+ * Entity data (either the entity's natural key or a copy of the data) is stored in all keys\n+ * that end with \"+<something>\". A count of all objects that match a particular top-level index\n+ * value is kept at the end marker (\"-<something>\"). A count is also kept at the natural index's end\n+ * marker, to make it easy to retrieve the number of all elements of a particular type.\n+ * </p>\n+ *\n+ * <p>\n+ * To illustrate, given a type \"Foo\", with a natural index and a second index called \"bar\", you'd\n+ * have these keys and values in the store for two instances, one with natural key \"key1\" and the\n+ * other \"key2\", both with value \"yes\" for \"bar\":\n+ * </p>\n+ *\n+ * <pre>\n+ * Foo __main__ +key1   [data for instance 1]\n+ * Foo __main__ +key2   [data for instance 2]\n+ * Foo __main__ -       [count of all Foo]\n+ * Foo bar +yes +key1   [instance 1 key or data, depending on index type]",
    "line": 86
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Because otherwise, when reading from the index, it's not that easy to parse the object's key from the leveldb key so that you can retrieve the object itself.\r\n\r\nYou also have to store something, leveldb doesn't allow you to store null.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-09-26T17:05:43Z",
    "diffHunk": "@@ -0,0 +1,516 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Holds metadata about app-specific types stored in LevelDB. Serves as a cache for data collected\n+ * via reflection, to make it cheaper to access it multiple times.\n+ *\n+ * <p>\n+ * The hierarchy of keys stored in LevelDB looks roughly like the following. This hierarchy ensures\n+ * that iteration over indices is easy, and that updating values in the store is not overly\n+ * expensive. Of note, indices choose using more disk space (one value per key) instead of keeping\n+ * lists of pointers, which would be more expensive to update at runtime.\n+ * </p>\n+ *\n+ * <p>\n+ * Indentation defines when a sub-key lives under a parent key. In LevelDB, this means the full\n+ * key would be the concatenation of everything up to that point in the hierarchy, with each\n+ * component separated by a NULL byte.\n+ * </p>\n+ *\n+ * <pre>\n+ * +TYPE_NAME\n+ *   NATURAL_INDEX\n+ *     +NATURAL_KEY\n+ *     -\n+ *   -NATURAL_INDEX\n+ *   INDEX_NAME\n+ *     +INDEX_VALUE\n+ *       +NATURAL_KEY\n+ *     -INDEX_VALUE\n+ *     .INDEX_VALUE\n+ *       CHILD_INDEX_NAME\n+ *         +CHILD_INDEX_VALUE\n+ *           NATURAL_KEY_OR_DATA\n+ *         -\n+ *   -INDEX_NAME\n+ * </pre>\n+ *\n+ * <p>\n+ * Entity data (either the entity's natural key or a copy of the data) is stored in all keys\n+ * that end with \"+<something>\". A count of all objects that match a particular top-level index\n+ * value is kept at the end marker (\"-<something>\"). A count is also kept at the natural index's end\n+ * marker, to make it easy to retrieve the number of all elements of a particular type.\n+ * </p>\n+ *\n+ * <p>\n+ * To illustrate, given a type \"Foo\", with a natural index and a second index called \"bar\", you'd\n+ * have these keys and values in the store for two instances, one with natural key \"key1\" and the\n+ * other \"key2\", both with value \"yes\" for \"bar\":\n+ * </p>\n+ *\n+ * <pre>\n+ * Foo __main__ +key1   [data for instance 1]\n+ * Foo __main__ +key2   [data for instance 2]\n+ * Foo __main__ -       [count of all Foo]\n+ * Foo bar +yes +key1   [instance 1 key or data, depending on index type]",
    "line": 86
  }],
  "prId": 17902
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "One question, do we really use the user-given index name in leveldb key? Since we have the type info, we can map user-given index name to some unique ids and use it in leveldb key, to save space.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-09-26T15:00:59Z",
    "diffHunk": "@@ -0,0 +1,516 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Holds metadata about app-specific types stored in LevelDB. Serves as a cache for data collected\n+ * via reflection, to make it cheaper to access it multiple times.\n+ *\n+ * <p>\n+ * The hierarchy of keys stored in LevelDB looks roughly like the following. This hierarchy ensures\n+ * that iteration over indices is easy, and that updating values in the store is not overly\n+ * expensive. Of note, indices choose using more disk space (one value per key) instead of keeping\n+ * lists of pointers, which would be more expensive to update at runtime.\n+ * </p>\n+ *\n+ * <p>\n+ * Indentation defines when a sub-key lives under a parent key. In LevelDB, this means the full\n+ * key would be the concatenation of everything up to that point in the hierarchy, with each\n+ * component separated by a NULL byte.\n+ * </p>\n+ *\n+ * <pre>\n+ * +TYPE_NAME\n+ *   NATURAL_INDEX\n+ *     +NATURAL_KEY\n+ *     -\n+ *   -NATURAL_INDEX\n+ *   INDEX_NAME\n+ *     +INDEX_VALUE\n+ *       +NATURAL_KEY\n+ *     -INDEX_VALUE\n+ *     .INDEX_VALUE\n+ *       CHILD_INDEX_NAME\n+ *         +CHILD_INDEX_VALUE\n+ *           NATURAL_KEY_OR_DATA\n+ *         -\n+ *   -INDEX_NAME\n+ * </pre>\n+ *\n+ * <p>\n+ * Entity data (either the entity's natural key or a copy of the data) is stored in all keys\n+ * that end with \"+<something>\". A count of all objects that match a particular top-level index\n+ * value is kept at the end marker (\"-<something>\"). A count is also kept at the natural index's end\n+ * marker, to make it easy to retrieve the number of all elements of a particular type.\n+ * </p>\n+ *\n+ * <p>\n+ * To illustrate, given a type \"Foo\", with a natural index and a second index called \"bar\", you'd\n+ * have these keys and values in the store for two instances, one with natural key \"key1\" and the\n+ * other \"key2\", both with value \"yes\" for \"bar\":\n+ * </p>\n+ *\n+ * <pre>\n+ * Foo __main__ +key1   [data for instance 1]\n+ * Foo __main__ +key2   [data for instance 2]\n+ * Foo __main__ -       [count of all Foo]\n+ * Foo bar +yes +key1   [instance 1 key or data, depending on index type]\n+ * Foo bar +yes +key2   [instance 2 key or data, depending on index type]\n+ * Foo bar +yes -       [count of all Foo with \"bar=yes\" ]\n+ * </pre>\n+ *\n+ * <p>\n+ * Note that all indexed values are prepended with \"+\", even if the index itself does not have an\n+ * explicit end marker. This allows for easily skipping to the end of an index by telling LevelDB\n+ * to seek to the \"phantom\" end marker of the index. Throughout the code and comments, this part\n+ * of the full LevelDB key is generally referred to as the \"index value\" of the entity.\n+ * </p>\n+ *\n+ * <p>\n+ * Child indices are stored after their parent index. In the example above, let's assume there is\n+ * a child index \"child\", whose parent is \"bar\". If both instances have value \"no\" for this field,\n+ * the data in the store would look something like the following:\n+ * </p>\n+ *\n+ * <pre>\n+ * ...\n+ * Foo bar +yes -\n+ * Foo bar .yes .child +no +key1   [instance 1 key or data, depending on index type]\n+ * Foo bar .yes .child +no +key2   [instance 2 key or data, depending on index type]",
    "line": 108
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "We could map the index name to a shorter identifier like it's done for types; but index names are generally short. And I've done some changes in code that uses this (not up for review yet) and shortening the index names doesn't end up saving a lot of space.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-09-26T17:03:03Z",
    "diffHunk": "@@ -0,0 +1,516 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Holds metadata about app-specific types stored in LevelDB. Serves as a cache for data collected\n+ * via reflection, to make it cheaper to access it multiple times.\n+ *\n+ * <p>\n+ * The hierarchy of keys stored in LevelDB looks roughly like the following. This hierarchy ensures\n+ * that iteration over indices is easy, and that updating values in the store is not overly\n+ * expensive. Of note, indices choose using more disk space (one value per key) instead of keeping\n+ * lists of pointers, which would be more expensive to update at runtime.\n+ * </p>\n+ *\n+ * <p>\n+ * Indentation defines when a sub-key lives under a parent key. In LevelDB, this means the full\n+ * key would be the concatenation of everything up to that point in the hierarchy, with each\n+ * component separated by a NULL byte.\n+ * </p>\n+ *\n+ * <pre>\n+ * +TYPE_NAME\n+ *   NATURAL_INDEX\n+ *     +NATURAL_KEY\n+ *     -\n+ *   -NATURAL_INDEX\n+ *   INDEX_NAME\n+ *     +INDEX_VALUE\n+ *       +NATURAL_KEY\n+ *     -INDEX_VALUE\n+ *     .INDEX_VALUE\n+ *       CHILD_INDEX_NAME\n+ *         +CHILD_INDEX_VALUE\n+ *           NATURAL_KEY_OR_DATA\n+ *         -\n+ *   -INDEX_NAME\n+ * </pre>\n+ *\n+ * <p>\n+ * Entity data (either the entity's natural key or a copy of the data) is stored in all keys\n+ * that end with \"+<something>\". A count of all objects that match a particular top-level index\n+ * value is kept at the end marker (\"-<something>\"). A count is also kept at the natural index's end\n+ * marker, to make it easy to retrieve the number of all elements of a particular type.\n+ * </p>\n+ *\n+ * <p>\n+ * To illustrate, given a type \"Foo\", with a natural index and a second index called \"bar\", you'd\n+ * have these keys and values in the store for two instances, one with natural key \"key1\" and the\n+ * other \"key2\", both with value \"yes\" for \"bar\":\n+ * </p>\n+ *\n+ * <pre>\n+ * Foo __main__ +key1   [data for instance 1]\n+ * Foo __main__ +key2   [data for instance 2]\n+ * Foo __main__ -       [count of all Foo]\n+ * Foo bar +yes +key1   [instance 1 key or data, depending on index type]\n+ * Foo bar +yes +key2   [instance 2 key or data, depending on index type]\n+ * Foo bar +yes -       [count of all Foo with \"bar=yes\" ]\n+ * </pre>\n+ *\n+ * <p>\n+ * Note that all indexed values are prepended with \"+\", even if the index itself does not have an\n+ * explicit end marker. This allows for easily skipping to the end of an index by telling LevelDB\n+ * to seek to the \"phantom\" end marker of the index. Throughout the code and comments, this part\n+ * of the full LevelDB key is generally referred to as the \"index value\" of the entity.\n+ * </p>\n+ *\n+ * <p>\n+ * Child indices are stored after their parent index. In the example above, let's assume there is\n+ * a child index \"child\", whose parent is \"bar\". If both instances have value \"no\" for this field,\n+ * the data in the store would look something like the following:\n+ * </p>\n+ *\n+ * <pre>\n+ * ...\n+ * Foo bar +yes -\n+ * Foo bar .yes .child +no +key1   [instance 1 key or data, depending on index type]\n+ * Foo bar .yes .child +no +key2   [instance 2 key or data, depending on index type]",
    "line": 108
  }],
  "prId": 17902
}, {
  "comments": [{
    "author": {
      "login": "ConeyLiu"
    },
    "body": "Hi @vanzin,  what's meaning for this `child`?",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2019-08-20T03:41:33Z",
    "diffHunk": "@@ -0,0 +1,516 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Holds metadata about app-specific types stored in LevelDB. Serves as a cache for data collected\n+ * via reflection, to make it cheaper to access it multiple times.\n+ *\n+ * <p>\n+ * The hierarchy of keys stored in LevelDB looks roughly like the following. This hierarchy ensures\n+ * that iteration over indices is easy, and that updating values in the store is not overly\n+ * expensive. Of note, indices choose using more disk space (one value per key) instead of keeping\n+ * lists of pointers, which would be more expensive to update at runtime.\n+ * </p>\n+ *\n+ * <p>\n+ * Indentation defines when a sub-key lives under a parent key. In LevelDB, this means the full\n+ * key would be the concatenation of everything up to that point in the hierarchy, with each\n+ * component separated by a NULL byte.\n+ * </p>\n+ *\n+ * <pre>\n+ * +TYPE_NAME\n+ *   NATURAL_INDEX\n+ *     +NATURAL_KEY\n+ *     -\n+ *   -NATURAL_INDEX\n+ *   INDEX_NAME\n+ *     +INDEX_VALUE\n+ *       +NATURAL_KEY\n+ *     -INDEX_VALUE\n+ *     .INDEX_VALUE\n+ *       CHILD_INDEX_NAME\n+ *         +CHILD_INDEX_VALUE\n+ *           NATURAL_KEY_OR_DATA\n+ *         -\n+ *   -INDEX_NAME\n+ * </pre>\n+ *\n+ * <p>\n+ * Entity data (either the entity's natural key or a copy of the data) is stored in all keys\n+ * that end with \"+<something>\". A count of all objects that match a particular top-level index\n+ * value is kept at the end marker (\"-<something>\"). A count is also kept at the natural index's end\n+ * marker, to make it easy to retrieve the number of all elements of a particular type.\n+ * </p>\n+ *\n+ * <p>\n+ * To illustrate, given a type \"Foo\", with a natural index and a second index called \"bar\", you'd\n+ * have these keys and values in the store for two instances, one with natural key \"key1\" and the\n+ * other \"key2\", both with value \"yes\" for \"bar\":\n+ * </p>\n+ *\n+ * <pre>\n+ * Foo __main__ +key1   [data for instance 1]\n+ * Foo __main__ +key2   [data for instance 2]\n+ * Foo __main__ -       [count of all Foo]\n+ * Foo bar +yes +key1   [instance 1 key or data, depending on index type]\n+ * Foo bar +yes +key2   [instance 2 key or data, depending on index type]\n+ * Foo bar +yes -       [count of all Foo with \"bar=yes\" ]\n+ * </pre>\n+ *\n+ * <p>\n+ * Note that all indexed values are prepended with \"+\", even if the index itself does not have an\n+ * explicit end marker. This allows for easily skipping to the end of an index by telling LevelDB\n+ * to seek to the \"phantom\" end marker of the index. Throughout the code and comments, this part\n+ * of the full LevelDB key is generally referred to as the \"index value\" of the entity.\n+ * </p>\n+ *\n+ * <p>\n+ * Child indices are stored after their parent index. In the example above, let's assume there is\n+ * a child index \"child\", whose parent is \"bar\". If both instances have value \"no\" for this field,\n+ * the data in the store would look something like the following:\n+ * </p>\n+ *\n+ * <pre>\n+ * ...\n+ * Foo bar +yes -\n+ * Foo bar .yes .child +no +key1   [instance 1 key or data, depending on index type]\n+ * Foo bar .yes .child +no +key2   [instance 2 key or data, depending on index type]\n+ * ...\n+ * </pre>\n+ */\n+class LevelDBTypeInfo {\n+\n+  static final byte[] END_MARKER = new byte[] { '-' };\n+  static final byte ENTRY_PREFIX = (byte) '+';\n+  static final byte KEY_SEPARATOR = 0x0;\n+  static byte TRUE = (byte) '1';\n+  static byte FALSE = (byte) '0';\n+\n+  private static final byte SECONDARY_IDX_PREFIX = (byte) '.';\n+  private static final byte POSITIVE_MARKER = (byte) '=';\n+  private static final byte NEGATIVE_MARKER = (byte) '*';\n+  private static final byte[] HEX_BYTES = new byte[] {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n+  };\n+\n+  private final LevelDB db;\n+  private final Class<?> type;\n+  private final Map<String, Index> indices;\n+  private final byte[] typePrefix;\n+\n+  LevelDBTypeInfo(LevelDB db, Class<?> type, byte[] alias) throws Exception {\n+    this.db = db;\n+    this.type = type;\n+    this.indices = new HashMap<>();\n+\n+    KVTypeInfo ti = new KVTypeInfo(type);\n+\n+    // First create the parent indices, then the child indices.\n+    ti.indices().forEach(idx -> {\n+      if (idx.parent().isEmpty()) {\n+        indices.put(idx.value(), new Index(idx, ti.getAccessor(idx.value()), null));\n+      }\n+    });\n+    ti.indices().forEach(idx -> {\n+      if (!idx.parent().isEmpty()) {\n+        indices.put(idx.value(), new Index(idx, ti.getAccessor(idx.value()),\n+          indices.get(idx.parent())));\n+      }\n+    });\n+\n+    this.typePrefix = alias;\n+  }\n+\n+  Class<?> type() {\n+    return type;\n+  }\n+\n+  byte[] keyPrefix() {\n+    return typePrefix;\n+  }\n+\n+  Index naturalIndex() {\n+    return index(KVIndex.NATURAL_INDEX_NAME);\n+  }\n+\n+  Index index(String name) {\n+    Index i = indices.get(name);\n+    Preconditions.checkArgument(i != null, \"Index %s does not exist for type %s.\", name,\n+      type.getName());\n+    return i;\n+  }\n+\n+  Collection<Index> indices() {\n+    return indices.values();\n+  }\n+\n+  byte[] buildKey(byte[]... components) {\n+    return buildKey(true, components);\n+  }\n+\n+  byte[] buildKey(boolean addTypePrefix, byte[]... components) {\n+    int len = 0;\n+    if (addTypePrefix) {\n+      len += typePrefix.length + 1;\n+    }\n+    for (byte[] comp : components) {\n+      len += comp.length;\n+    }\n+    len += components.length - 1;\n+\n+    byte[] dest = new byte[len];\n+    int written = 0;\n+\n+    if (addTypePrefix) {\n+      System.arraycopy(typePrefix, 0, dest, 0, typePrefix.length);\n+      dest[typePrefix.length] = KEY_SEPARATOR;\n+      written += typePrefix.length + 1;\n+    }\n+\n+    for (byte[] comp : components) {\n+      System.arraycopy(comp, 0, dest, written, comp.length);\n+      written += comp.length;\n+      if (written < dest.length) {\n+        dest[written] = KEY_SEPARATOR;\n+        written++;\n+      }\n+    }\n+\n+    return dest;\n+  }\n+\n+  /**\n+   * Models a single index in LevelDB. See top-level class's javadoc for a description of how the\n+   * keys are generated.\n+   */\n+  class Index {\n+\n+    private final boolean copy;\n+    private final boolean isNatural;\n+    private final byte[] name;\n+    private final KVTypeInfo.Accessor accessor;\n+    private final Index parent;\n+\n+    private Index(KVIndex self, KVTypeInfo.Accessor accessor, Index parent) {\n+      byte[] name = self.value().getBytes(UTF_8);\n+      if (parent != null) {\n+        byte[] child = new byte[name.length + 1];",
    "line": 228
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Looks like dead code.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2019-08-20T16:43:34Z",
    "diffHunk": "@@ -0,0 +1,516 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Holds metadata about app-specific types stored in LevelDB. Serves as a cache for data collected\n+ * via reflection, to make it cheaper to access it multiple times.\n+ *\n+ * <p>\n+ * The hierarchy of keys stored in LevelDB looks roughly like the following. This hierarchy ensures\n+ * that iteration over indices is easy, and that updating values in the store is not overly\n+ * expensive. Of note, indices choose using more disk space (one value per key) instead of keeping\n+ * lists of pointers, which would be more expensive to update at runtime.\n+ * </p>\n+ *\n+ * <p>\n+ * Indentation defines when a sub-key lives under a parent key. In LevelDB, this means the full\n+ * key would be the concatenation of everything up to that point in the hierarchy, with each\n+ * component separated by a NULL byte.\n+ * </p>\n+ *\n+ * <pre>\n+ * +TYPE_NAME\n+ *   NATURAL_INDEX\n+ *     +NATURAL_KEY\n+ *     -\n+ *   -NATURAL_INDEX\n+ *   INDEX_NAME\n+ *     +INDEX_VALUE\n+ *       +NATURAL_KEY\n+ *     -INDEX_VALUE\n+ *     .INDEX_VALUE\n+ *       CHILD_INDEX_NAME\n+ *         +CHILD_INDEX_VALUE\n+ *           NATURAL_KEY_OR_DATA\n+ *         -\n+ *   -INDEX_NAME\n+ * </pre>\n+ *\n+ * <p>\n+ * Entity data (either the entity's natural key or a copy of the data) is stored in all keys\n+ * that end with \"+<something>\". A count of all objects that match a particular top-level index\n+ * value is kept at the end marker (\"-<something>\"). A count is also kept at the natural index's end\n+ * marker, to make it easy to retrieve the number of all elements of a particular type.\n+ * </p>\n+ *\n+ * <p>\n+ * To illustrate, given a type \"Foo\", with a natural index and a second index called \"bar\", you'd\n+ * have these keys and values in the store for two instances, one with natural key \"key1\" and the\n+ * other \"key2\", both with value \"yes\" for \"bar\":\n+ * </p>\n+ *\n+ * <pre>\n+ * Foo __main__ +key1   [data for instance 1]\n+ * Foo __main__ +key2   [data for instance 2]\n+ * Foo __main__ -       [count of all Foo]\n+ * Foo bar +yes +key1   [instance 1 key or data, depending on index type]\n+ * Foo bar +yes +key2   [instance 2 key or data, depending on index type]\n+ * Foo bar +yes -       [count of all Foo with \"bar=yes\" ]\n+ * </pre>\n+ *\n+ * <p>\n+ * Note that all indexed values are prepended with \"+\", even if the index itself does not have an\n+ * explicit end marker. This allows for easily skipping to the end of an index by telling LevelDB\n+ * to seek to the \"phantom\" end marker of the index. Throughout the code and comments, this part\n+ * of the full LevelDB key is generally referred to as the \"index value\" of the entity.\n+ * </p>\n+ *\n+ * <p>\n+ * Child indices are stored after their parent index. In the example above, let's assume there is\n+ * a child index \"child\", whose parent is \"bar\". If both instances have value \"no\" for this field,\n+ * the data in the store would look something like the following:\n+ * </p>\n+ *\n+ * <pre>\n+ * ...\n+ * Foo bar +yes -\n+ * Foo bar .yes .child +no +key1   [instance 1 key or data, depending on index type]\n+ * Foo bar .yes .child +no +key2   [instance 2 key or data, depending on index type]\n+ * ...\n+ * </pre>\n+ */\n+class LevelDBTypeInfo {\n+\n+  static final byte[] END_MARKER = new byte[] { '-' };\n+  static final byte ENTRY_PREFIX = (byte) '+';\n+  static final byte KEY_SEPARATOR = 0x0;\n+  static byte TRUE = (byte) '1';\n+  static byte FALSE = (byte) '0';\n+\n+  private static final byte SECONDARY_IDX_PREFIX = (byte) '.';\n+  private static final byte POSITIVE_MARKER = (byte) '=';\n+  private static final byte NEGATIVE_MARKER = (byte) '*';\n+  private static final byte[] HEX_BYTES = new byte[] {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n+  };\n+\n+  private final LevelDB db;\n+  private final Class<?> type;\n+  private final Map<String, Index> indices;\n+  private final byte[] typePrefix;\n+\n+  LevelDBTypeInfo(LevelDB db, Class<?> type, byte[] alias) throws Exception {\n+    this.db = db;\n+    this.type = type;\n+    this.indices = new HashMap<>();\n+\n+    KVTypeInfo ti = new KVTypeInfo(type);\n+\n+    // First create the parent indices, then the child indices.\n+    ti.indices().forEach(idx -> {\n+      if (idx.parent().isEmpty()) {\n+        indices.put(idx.value(), new Index(idx, ti.getAccessor(idx.value()), null));\n+      }\n+    });\n+    ti.indices().forEach(idx -> {\n+      if (!idx.parent().isEmpty()) {\n+        indices.put(idx.value(), new Index(idx, ti.getAccessor(idx.value()),\n+          indices.get(idx.parent())));\n+      }\n+    });\n+\n+    this.typePrefix = alias;\n+  }\n+\n+  Class<?> type() {\n+    return type;\n+  }\n+\n+  byte[] keyPrefix() {\n+    return typePrefix;\n+  }\n+\n+  Index naturalIndex() {\n+    return index(KVIndex.NATURAL_INDEX_NAME);\n+  }\n+\n+  Index index(String name) {\n+    Index i = indices.get(name);\n+    Preconditions.checkArgument(i != null, \"Index %s does not exist for type %s.\", name,\n+      type.getName());\n+    return i;\n+  }\n+\n+  Collection<Index> indices() {\n+    return indices.values();\n+  }\n+\n+  byte[] buildKey(byte[]... components) {\n+    return buildKey(true, components);\n+  }\n+\n+  byte[] buildKey(boolean addTypePrefix, byte[]... components) {\n+    int len = 0;\n+    if (addTypePrefix) {\n+      len += typePrefix.length + 1;\n+    }\n+    for (byte[] comp : components) {\n+      len += comp.length;\n+    }\n+    len += components.length - 1;\n+\n+    byte[] dest = new byte[len];\n+    int written = 0;\n+\n+    if (addTypePrefix) {\n+      System.arraycopy(typePrefix, 0, dest, 0, typePrefix.length);\n+      dest[typePrefix.length] = KEY_SEPARATOR;\n+      written += typePrefix.length + 1;\n+    }\n+\n+    for (byte[] comp : components) {\n+      System.arraycopy(comp, 0, dest, written, comp.length);\n+      written += comp.length;\n+      if (written < dest.length) {\n+        dest[written] = KEY_SEPARATOR;\n+        written++;\n+      }\n+    }\n+\n+    return dest;\n+  }\n+\n+  /**\n+   * Models a single index in LevelDB. See top-level class's javadoc for a description of how the\n+   * keys are generated.\n+   */\n+  class Index {\n+\n+    private final boolean copy;\n+    private final boolean isNatural;\n+    private final byte[] name;\n+    private final KVTypeInfo.Accessor accessor;\n+    private final Index parent;\n+\n+    private Index(KVIndex self, KVTypeInfo.Accessor accessor, Index parent) {\n+      byte[] name = self.value().getBytes(UTF_8);\n+      if (parent != null) {\n+        byte[] child = new byte[name.length + 1];",
    "line": 228
  }],
  "prId": 17902
}]