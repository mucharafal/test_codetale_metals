[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "this requires the fields & methods to be public, right?  That shoudl go in the doc for `@KVIndex`, or you can call `setAccessible(true)` in the constructor.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-05-31T16:40:40Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Wrapper around types managed in a KVStore, providing easy access to their indexed fields.\n+ */\n+public class KVTypeInfo {\n+\n+  private final Class<?> type;\n+  private final Map<String, KVIndex> indices;\n+  private final Map<String, Accessor> accessors;\n+\n+  public KVTypeInfo(Class<?> type) throws Exception {\n+    this.type = type;\n+    this.accessors = new HashMap<>();\n+    this.indices = new HashMap<>();\n+\n+    for (Field f : type.getFields()) {\n+      KVIndex idx = f.getAnnotation(KVIndex.class);\n+      if (idx != null) {\n+        checkIndex(idx, indices);\n+        indices.put(idx.value(), idx);\n+        accessors.put(idx.value(), new FieldAccessor(f));\n+      }\n+    }\n+\n+    for (Method m : type.getMethods()) {\n+      KVIndex idx = m.getAnnotation(KVIndex.class);\n+      if (idx != null) {\n+        checkIndex(idx, indices);\n+        Preconditions.checkArgument(m.getParameterTypes().length == 0,\n+          \"Annotated method %s::%s should not have any parameters.\", type.getName(), m.getName());\n+        indices.put(idx.value(), idx);\n+        accessors.put(idx.value(), new MethodAccessor(m));\n+      }\n+    }\n+\n+    Preconditions.checkArgument(indices.containsKey(KVIndex.NATURAL_INDEX_NAME),\n+        \"No natural index defined for type %s.\", type.getName());\n+    Preconditions.checkArgument(indices.get(KVIndex.NATURAL_INDEX_NAME).parent().isEmpty(),\n+        \"Natural index of %s cannot have a parent.\", type.getName());\n+\n+    for (KVIndex idx : indices.values()) {\n+      if (!idx.parent().isEmpty()) {\n+        KVIndex parent = indices.get(idx.parent());\n+        Preconditions.checkArgument(parent != null,\n+          \"Cannot find parent %s of index %s.\", idx.parent(), idx.value());\n+        Preconditions.checkArgument(parent.parent().isEmpty(),\n+          \"Parent index %s of index %s cannot be itself a child index.\", idx.parent(), idx.value());\n+      }\n+    }\n+  }\n+\n+  private void checkIndex(KVIndex idx, Map<String, KVIndex> indices) {\n+    Preconditions.checkArgument(idx.value() != null && !idx.value().isEmpty(),\n+      \"No name provided for index in type %s.\", type.getName());\n+    Preconditions.checkArgument(\n+      !idx.value().startsWith(\"_\") || idx.value().equals(KVIndex.NATURAL_INDEX_NAME),\n+      \"Index name %s (in type %s) is not allowed.\", idx.value(), type.getName());\n+    Preconditions.checkArgument(idx.parent().isEmpty() || !idx.parent().equals(idx.value()),\n+      \"Index %s cannot be parent of itself.\", idx.value());\n+    Preconditions.checkArgument(!indices.containsKey(idx.value()),\n+      \"Duplicate index %s for type %s.\", idx.value(), type.getName());\n+  }\n+\n+  public Class<?> getType() {\n+    return type;\n+  }\n+\n+  public Object getIndexValue(String indexName, Object instance) throws Exception {\n+    return getAccessor(indexName).get(instance);\n+  }\n+\n+  public Stream<KVIndex> indices() {\n+    return indices.values().stream();\n+  }\n+\n+  Accessor getAccessor(String indexName) {\n+    Accessor a = accessors.get(indexName);\n+    Preconditions.checkArgument(a != null, \"No index %s.\", indexName);\n+    return a;\n+  }\n+\n+  Accessor getParentAccessor(String indexName) {\n+    KVIndex index = indices.get(indexName);\n+    return index.parent().isEmpty() ? null : getAccessor(index.parent());\n+  }\n+\n+  /**\n+   * Abstracts the difference between invoking a Field and a Method.\n+   */\n+  interface Accessor {\n+\n+    Object get(Object instance) throws Exception;\n+\n+  }\n+\n+  private class FieldAccessor implements Accessor {\n+\n+    private final Field field;\n+\n+    FieldAccessor(Field field) {\n+      this.field = field;\n+    }\n+\n+    @Override\n+    public Object get(Object instance) throws Exception {\n+      return field.get(instance);",
    "line": 136
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I thought I had included that change here but it ended up in another patch... will add it here instead.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-05-31T20:06:21Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Wrapper around types managed in a KVStore, providing easy access to their indexed fields.\n+ */\n+public class KVTypeInfo {\n+\n+  private final Class<?> type;\n+  private final Map<String, KVIndex> indices;\n+  private final Map<String, Accessor> accessors;\n+\n+  public KVTypeInfo(Class<?> type) throws Exception {\n+    this.type = type;\n+    this.accessors = new HashMap<>();\n+    this.indices = new HashMap<>();\n+\n+    for (Field f : type.getFields()) {\n+      KVIndex idx = f.getAnnotation(KVIndex.class);\n+      if (idx != null) {\n+        checkIndex(idx, indices);\n+        indices.put(idx.value(), idx);\n+        accessors.put(idx.value(), new FieldAccessor(f));\n+      }\n+    }\n+\n+    for (Method m : type.getMethods()) {\n+      KVIndex idx = m.getAnnotation(KVIndex.class);\n+      if (idx != null) {\n+        checkIndex(idx, indices);\n+        Preconditions.checkArgument(m.getParameterTypes().length == 0,\n+          \"Annotated method %s::%s should not have any parameters.\", type.getName(), m.getName());\n+        indices.put(idx.value(), idx);\n+        accessors.put(idx.value(), new MethodAccessor(m));\n+      }\n+    }\n+\n+    Preconditions.checkArgument(indices.containsKey(KVIndex.NATURAL_INDEX_NAME),\n+        \"No natural index defined for type %s.\", type.getName());\n+    Preconditions.checkArgument(indices.get(KVIndex.NATURAL_INDEX_NAME).parent().isEmpty(),\n+        \"Natural index of %s cannot have a parent.\", type.getName());\n+\n+    for (KVIndex idx : indices.values()) {\n+      if (!idx.parent().isEmpty()) {\n+        KVIndex parent = indices.get(idx.parent());\n+        Preconditions.checkArgument(parent != null,\n+          \"Cannot find parent %s of index %s.\", idx.parent(), idx.value());\n+        Preconditions.checkArgument(parent.parent().isEmpty(),\n+          \"Parent index %s of index %s cannot be itself a child index.\", idx.parent(), idx.value());\n+      }\n+    }\n+  }\n+\n+  private void checkIndex(KVIndex idx, Map<String, KVIndex> indices) {\n+    Preconditions.checkArgument(idx.value() != null && !idx.value().isEmpty(),\n+      \"No name provided for index in type %s.\", type.getName());\n+    Preconditions.checkArgument(\n+      !idx.value().startsWith(\"_\") || idx.value().equals(KVIndex.NATURAL_INDEX_NAME),\n+      \"Index name %s (in type %s) is not allowed.\", idx.value(), type.getName());\n+    Preconditions.checkArgument(idx.parent().isEmpty() || !idx.parent().equals(idx.value()),\n+      \"Index %s cannot be parent of itself.\", idx.value());\n+    Preconditions.checkArgument(!indices.containsKey(idx.value()),\n+      \"Duplicate index %s for type %s.\", idx.value(), type.getName());\n+  }\n+\n+  public Class<?> getType() {\n+    return type;\n+  }\n+\n+  public Object getIndexValue(String indexName, Object instance) throws Exception {\n+    return getAccessor(indexName).get(instance);\n+  }\n+\n+  public Stream<KVIndex> indices() {\n+    return indices.values().stream();\n+  }\n+\n+  Accessor getAccessor(String indexName) {\n+    Accessor a = accessors.get(indexName);\n+    Preconditions.checkArgument(a != null, \"No index %s.\", indexName);\n+    return a;\n+  }\n+\n+  Accessor getParentAccessor(String indexName) {\n+    KVIndex index = indices.get(indexName);\n+    return index.parent().isEmpty() ? null : getAccessor(index.parent());\n+  }\n+\n+  /**\n+   * Abstracts the difference between invoking a Field and a Method.\n+   */\n+  interface Accessor {\n+\n+    Object get(Object instance) throws Exception;\n+\n+  }\n+\n+  private class FieldAccessor implements Accessor {\n+\n+    private final Field field;\n+\n+    FieldAccessor(Field field) {\n+      this.field = field;\n+    }\n+\n+    @Override\n+    public Object get(Object instance) throws Exception {\n+      return field.get(instance);",
    "line": 136
  }],
  "prId": 17902
}]