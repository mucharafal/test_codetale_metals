[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "if the key is null, I guess this will complain somewhere in here, but a nicer error msg would be better.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-05-31T16:50:34Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.fusesource.leveldbjni.JniDBFactory;\n+import org.iq80.leveldb.DB;\n+import org.iq80.leveldb.Options;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Implementation of KVStore that uses LevelDB as the underlying data store.\n+ */\n+public class LevelDB implements KVStore {\n+\n+  @VisibleForTesting\n+  static final long STORE_VERSION = 1L;\n+\n+  @VisibleForTesting\n+  static final byte[] STORE_VERSION_KEY = \"__version__\".getBytes(UTF_8);\n+\n+  /** DB key where app metadata is stored. */\n+  private static final byte[] METADATA_KEY = \"__meta__\".getBytes(UTF_8);\n+\n+  /** DB key where type aliases are stored. */\n+  private static final byte[] TYPE_ALIASES_KEY = \"__types__\".getBytes(UTF_8);\n+\n+  final AtomicReference<DB> _db;\n+  final KVStoreSerializer serializer;\n+\n+  private final ConcurrentMap<String, byte[]> typeAliases;\n+  private final ConcurrentMap<Class<?>, LevelDBTypeInfo> types;\n+\n+  public LevelDB(File path) throws Exception {\n+    this(path, new KVStoreSerializer());\n+  }\n+\n+  public LevelDB(File path, KVStoreSerializer serializer) throws Exception {\n+    this.serializer = serializer;\n+    this.types = new ConcurrentHashMap<>();\n+\n+    Options options = new Options();\n+    options.createIfMissing(!path.exists());\n+    this._db = new AtomicReference<>(JniDBFactory.factory.open(path, options));\n+\n+    byte[] versionData = db().get(STORE_VERSION_KEY);\n+    if (versionData != null) {\n+      long version = serializer.deserializeLong(versionData);\n+      if (version != STORE_VERSION) {\n+        throw new UnsupportedStoreVersionException();\n+      }\n+    } else {\n+      db().put(STORE_VERSION_KEY, serializer.serialize(STORE_VERSION));\n+    }\n+\n+    Map<String, byte[]> aliases;\n+    try {\n+      aliases = get(TYPE_ALIASES_KEY, TypeAliases.class).aliases;\n+    } catch (NoSuchElementException e) {\n+      aliases = new HashMap<>();\n+    }\n+    typeAliases = new ConcurrentHashMap<>(aliases);\n+  }\n+\n+  @Override\n+  public <T> T getMetadata(Class<T> klass) throws Exception {\n+    try {\n+      return get(METADATA_KEY, klass);\n+    } catch (NoSuchElementException nsee) {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void setMetadata(Object value) throws Exception {\n+    if (value != null) {\n+      put(METADATA_KEY, value);\n+    } else {\n+      db().delete(METADATA_KEY);\n+    }\n+  }\n+\n+  <T> T get(byte[] key, Class<T> klass) throws Exception {\n+    byte[] data = db().get(key);\n+    if (data == null) {\n+      throw new NoSuchElementException(new String(key, UTF_8));\n+    }\n+    return serializer.deserialize(data, klass);\n+  }\n+\n+  private void put(byte[] key, Object value) throws Exception {\n+    Preconditions.checkArgument(value != null, \"Null values are not allowed.\");\n+    db().put(key, serializer.serialize(value));\n+  }\n+\n+  @Override\n+  public <T> T read(Class<T> klass, Object naturalKey) throws Exception {\n+    Preconditions.checkArgument(naturalKey != null, \"Null keys are not allowed.\");\n+    byte[] key = getTypeInfo(klass).naturalIndex().start(null, naturalKey);\n+    return get(key, klass);\n+  }\n+\n+  @Override\n+  public void write(Object value) throws Exception {\n+    Preconditions.checkArgument(value != null, \"Null values are not allowed.\");\n+    LevelDBTypeInfo ti = getTypeInfo(value.getClass());\n+\n+    try (WriteBatch batch = db().createWriteBatch()) {\n+      byte[] data = serializer.serialize(value);\n+      synchronized (ti) {\n+        Object existing;\n+        try {\n+          existing = get(ti.naturalIndex().entityKey(null, value), value.getClass());\n+        } catch (NoSuchElementException e) {\n+          existing = null;\n+        }\n+\n+        PrefixCache cache = new PrefixCache(value);\n+        byte[] naturalKey = ti.naturalIndex().toKey(ti.naturalIndex().getValue(value));",
    "line": 153
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "In LevelDBTypeInfo.java:\r\n\r\n```\r\n      Preconditions.checkNotNull(indexValue, \"Null index value for %s in type %s.\",\r\n        name, type.getName());\r\n```",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-05-31T20:14:28Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.fusesource.leveldbjni.JniDBFactory;\n+import org.iq80.leveldb.DB;\n+import org.iq80.leveldb.Options;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Implementation of KVStore that uses LevelDB as the underlying data store.\n+ */\n+public class LevelDB implements KVStore {\n+\n+  @VisibleForTesting\n+  static final long STORE_VERSION = 1L;\n+\n+  @VisibleForTesting\n+  static final byte[] STORE_VERSION_KEY = \"__version__\".getBytes(UTF_8);\n+\n+  /** DB key where app metadata is stored. */\n+  private static final byte[] METADATA_KEY = \"__meta__\".getBytes(UTF_8);\n+\n+  /** DB key where type aliases are stored. */\n+  private static final byte[] TYPE_ALIASES_KEY = \"__types__\".getBytes(UTF_8);\n+\n+  final AtomicReference<DB> _db;\n+  final KVStoreSerializer serializer;\n+\n+  private final ConcurrentMap<String, byte[]> typeAliases;\n+  private final ConcurrentMap<Class<?>, LevelDBTypeInfo> types;\n+\n+  public LevelDB(File path) throws Exception {\n+    this(path, new KVStoreSerializer());\n+  }\n+\n+  public LevelDB(File path, KVStoreSerializer serializer) throws Exception {\n+    this.serializer = serializer;\n+    this.types = new ConcurrentHashMap<>();\n+\n+    Options options = new Options();\n+    options.createIfMissing(!path.exists());\n+    this._db = new AtomicReference<>(JniDBFactory.factory.open(path, options));\n+\n+    byte[] versionData = db().get(STORE_VERSION_KEY);\n+    if (versionData != null) {\n+      long version = serializer.deserializeLong(versionData);\n+      if (version != STORE_VERSION) {\n+        throw new UnsupportedStoreVersionException();\n+      }\n+    } else {\n+      db().put(STORE_VERSION_KEY, serializer.serialize(STORE_VERSION));\n+    }\n+\n+    Map<String, byte[]> aliases;\n+    try {\n+      aliases = get(TYPE_ALIASES_KEY, TypeAliases.class).aliases;\n+    } catch (NoSuchElementException e) {\n+      aliases = new HashMap<>();\n+    }\n+    typeAliases = new ConcurrentHashMap<>(aliases);\n+  }\n+\n+  @Override\n+  public <T> T getMetadata(Class<T> klass) throws Exception {\n+    try {\n+      return get(METADATA_KEY, klass);\n+    } catch (NoSuchElementException nsee) {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void setMetadata(Object value) throws Exception {\n+    if (value != null) {\n+      put(METADATA_KEY, value);\n+    } else {\n+      db().delete(METADATA_KEY);\n+    }\n+  }\n+\n+  <T> T get(byte[] key, Class<T> klass) throws Exception {\n+    byte[] data = db().get(key);\n+    if (data == null) {\n+      throw new NoSuchElementException(new String(key, UTF_8));\n+    }\n+    return serializer.deserialize(data, klass);\n+  }\n+\n+  private void put(byte[] key, Object value) throws Exception {\n+    Preconditions.checkArgument(value != null, \"Null values are not allowed.\");\n+    db().put(key, serializer.serialize(value));\n+  }\n+\n+  @Override\n+  public <T> T read(Class<T> klass, Object naturalKey) throws Exception {\n+    Preconditions.checkArgument(naturalKey != null, \"Null keys are not allowed.\");\n+    byte[] key = getTypeInfo(klass).naturalIndex().start(null, naturalKey);\n+    return get(key, klass);\n+  }\n+\n+  @Override\n+  public void write(Object value) throws Exception {\n+    Preconditions.checkArgument(value != null, \"Null values are not allowed.\");\n+    LevelDBTypeInfo ti = getTypeInfo(value.getClass());\n+\n+    try (WriteBatch batch = db().createWriteBatch()) {\n+      byte[] data = serializer.serialize(value);\n+      synchronized (ti) {\n+        Object existing;\n+        try {\n+          existing = get(ti.naturalIndex().entityKey(null, value), value.getClass());\n+        } catch (NoSuchElementException e) {\n+          existing = null;\n+        }\n+\n+        PrefixCache cache = new PrefixCache(value);\n+        byte[] naturalKey = ti.naturalIndex().toKey(ti.naturalIndex().getValue(value));",
    "line": 153
  }],
  "prId": 17902
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "this `typeAliases` thing is pretty confusing.  IIUC, the idea is to replace a long fully qualified type name with a shorter numeric id, and this holds the mapping?  I'd include a comment about it.  maybe even rename `typetoID`.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-05-31T17:24:01Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import org.fusesource.leveldbjni.JniDBFactory;\n+import org.iq80.leveldb.DB;\n+import org.iq80.leveldb.Options;\n+import org.iq80.leveldb.WriteBatch;\n+\n+/**\n+ * Implementation of KVStore that uses LevelDB as the underlying data store.\n+ */\n+public class LevelDB implements KVStore {\n+\n+  @VisibleForTesting\n+  static final long STORE_VERSION = 1L;\n+\n+  @VisibleForTesting\n+  static final byte[] STORE_VERSION_KEY = \"__version__\".getBytes(UTF_8);\n+\n+  /** DB key where app metadata is stored. */\n+  private static final byte[] METADATA_KEY = \"__meta__\".getBytes(UTF_8);\n+\n+  /** DB key where type aliases are stored. */\n+  private static final byte[] TYPE_ALIASES_KEY = \"__types__\".getBytes(UTF_8);\n+\n+  final AtomicReference<DB> _db;\n+  final KVStoreSerializer serializer;\n+\n+  private final ConcurrentMap<String, byte[]> typeAliases;"
  }],
  "prId": 17902
}]