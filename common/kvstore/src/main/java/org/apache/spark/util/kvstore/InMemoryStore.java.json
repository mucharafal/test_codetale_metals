[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: space after `)`",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-15T23:31:26Z",
    "diffHunk": "@@ -126,64 +132,144 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>)data.get(type);"
  }],
  "prId": 24616
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: private, final where it makes sense",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-15T23:33:03Z",
    "diffHunk": "@@ -126,64 +132,144 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>)data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      ConcurrentMap<Comparable<Object>, T> data;"
  }],
  "prId": 24616
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This comment sounds like it belongs at this class's declaration, not inside this method?",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-15T23:34:49Z",
    "diffHunk": "@@ -126,64 +132,144 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>)data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      ConcurrentMap<Comparable<Object>, T> data;\n+      Predicate<? super T> filter;\n+      int count = 0;\n+\n+      CountingRemoveIfForEach(\n+          ConcurrentMap<Comparable<Object>, T> data,\n+          Predicate<? super T> filter) {\n+        this.data = data;\n+        this.filter = filter;\n+      }\n+\n+      public void accept(Comparable<Object> key, T value) {\n+        // To address https://bugs.openjdk.java.net/browse/JDK-8078645 which affects remove() on"
  }],
  "prId": 24616
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "IIUC you're removing all entries whose value corresponding to the given index match the given `keys` list.\r\n\r\nSo it sounds to me like the name here (and in related code) should use `ByValues` instead of `ByKeys`?\r\n\r\nAlso, you have a raw type in the argument list, which tells me that your `@SuppressWarnings` is either incorrect or perhaps not needed (if you make the argument `Collection<?>`).",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-15T23:40:07Z",
    "diffHunk": "@@ -126,64 +132,144 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>)data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      ConcurrentMap<Comparable<Object>, T> data;\n+      Predicate<? super T> filter;\n+      int count = 0;\n+\n+      CountingRemoveIfForEach(\n+          ConcurrentMap<Comparable<Object>, T> data,\n+          Predicate<? super T> filter) {\n+        this.data = data;\n+        this.filter = filter;\n+      }\n+\n+      public void accept(Comparable<Object> key, T value) {\n+        // To address https://bugs.openjdk.java.net/browse/JDK-8078645 which affects remove() on\n+        // all iterators of concurrent maps, and specifically makes countingRemoveIf difficult to\n+        // implement correctly against the values() iterator, we use forEach instead....\n+        if (filter.test(value)) {\n+          if (data.remove(key, value)) {\n+            count++;\n+          }\n+        }\n+      }\n+    }\n \n     private final KVTypeInfo ti;\n     private final KVTypeInfo.Accessor naturalKey;\n-    private final ConcurrentMap<Comparable<Object>, Object> data;\n-\n-    private int size;\n+    private final ConcurrentMap<Comparable<Object>, T> data;\n \n-    private InstanceList(Class<?> type) throws Exception {\n-      this.ti = new KVTypeInfo(type);\n+    private InstanceList(Class<?> klass) {\n+      this.ti = new KVTypeInfo(klass);\n       this.naturalKey = ti.getAccessor(KVIndex.NATURAL_INDEX_NAME);\n       this.data = new ConcurrentHashMap<>();\n-      this.size = 0;\n     }\n \n     KVTypeInfo.Accessor getIndexAccessor(String indexName) {\n       return ti.getAccessor(indexName);\n     }\n \n-    public Object get(Object key) {\n+    // Note: removeIf returns a boolean if any element has been removed.\n+    // While debugging this code, it was handy to have the count of elements\n+    // removed, rather than an indicator of whether something has been\n+    // removed, and a count is no more complicated than a boolean so I've\n+    // retained that behavior here, although there is no current requirement.\n+    @SuppressWarnings(\"unchecked\")\n+    int countingRemoveAllByKeys(String index, Collection keys) {"
  }, {
    "author": {
      "login": "davidnavas"
    },
    "body": "I'm removing values whose key indicated by \"index\" matches (one of) the passed keys.\r\nSo, I'm matching keys, hence the ByKeys and the keyFromValue which retrieves the key indicated by 'getter' of the passed value.\r\nBTW, I think I could add generic typing to Accessor<V, K> and ensure that the getter and value objects match, but I don't think the K type would turn out to be terribly useful, as ultimately there's no match between the index (a String) and the key type.  Let me know if you think that's useful.\r\n\r\nYes, I'll try to use the <?> in a number of the SuppressWarnings and see what happens.  It might be possible to get rid of a number of them, which would be fabulous.",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-16T02:40:37Z",
    "diffHunk": "@@ -126,64 +132,144 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>)data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      ConcurrentMap<Comparable<Object>, T> data;\n+      Predicate<? super T> filter;\n+      int count = 0;\n+\n+      CountingRemoveIfForEach(\n+          ConcurrentMap<Comparable<Object>, T> data,\n+          Predicate<? super T> filter) {\n+        this.data = data;\n+        this.filter = filter;\n+      }\n+\n+      public void accept(Comparable<Object> key, T value) {\n+        // To address https://bugs.openjdk.java.net/browse/JDK-8078645 which affects remove() on\n+        // all iterators of concurrent maps, and specifically makes countingRemoveIf difficult to\n+        // implement correctly against the values() iterator, we use forEach instead....\n+        if (filter.test(value)) {\n+          if (data.remove(key, value)) {\n+            count++;\n+          }\n+        }\n+      }\n+    }\n \n     private final KVTypeInfo ti;\n     private final KVTypeInfo.Accessor naturalKey;\n-    private final ConcurrentMap<Comparable<Object>, Object> data;\n-\n-    private int size;\n+    private final ConcurrentMap<Comparable<Object>, T> data;\n \n-    private InstanceList(Class<?> type) throws Exception {\n-      this.ti = new KVTypeInfo(type);\n+    private InstanceList(Class<?> klass) {\n+      this.ti = new KVTypeInfo(klass);\n       this.naturalKey = ti.getAccessor(KVIndex.NATURAL_INDEX_NAME);\n       this.data = new ConcurrentHashMap<>();\n-      this.size = 0;\n     }\n \n     KVTypeInfo.Accessor getIndexAccessor(String indexName) {\n       return ti.getAccessor(indexName);\n     }\n \n-    public Object get(Object key) {\n+    // Note: removeIf returns a boolean if any element has been removed.\n+    // While debugging this code, it was handy to have the count of elements\n+    // removed, rather than an indicator of whether something has been\n+    // removed, and a count is no more complicated than a boolean so I've\n+    // retained that behavior here, although there is no current requirement.\n+    @SuppressWarnings(\"unchecked\")\n+    int countingRemoveAllByKeys(String index, Collection keys) {"
  }, {
    "author": {
      "login": "davidnavas"
    },
    "body": "Hmm, I suspect we have a terminology overload issue here.\r\n1) The read|write|view methods on KVStore refer to the things you read, write, and look at as \"instance\", \"object\", and \"entities\" respectively (and also \"value\" for write() as the name of the parameter).\r\n2) read() provides a \"naturalKey\" to access a specific instance, which is the value of the unique/primary/NATURAL_INDEX_NAME index\r\n3) KVStoreView refers to the values of an index as passed in first() and last() as values, not keys -- naturalKey or no\r\n4) InMemoryStore refers to the Comparable wrappers placed around the values of a particular index as a key.\r\n5) KVStore seems to say that the key is actually created per type written and are based on the type name (which itself is referred to as either klass or type)\r\n\r\nSo, yes, I'm probably using terminology wrong, and I hereby declare myself confused :(\r\n\r\nWith respect to klass vs type I had gone with klass in the removeAll___() as it was consistent with having 'klass' everywhere in the ElementTrackingStore, but please let me know if that should be changed!\r\n\r\nWith respect to key, value, field-value-for-index, comparable-wrapper-around-field-value-for-index, I admit to not knowing what to call which things when.  One way to deal with this is to make the removeAll on the KVStoreView, where \"value\" is everywhere (I think) considered in the context of the type and index.  The upside is that we could naturally call such a method removeAll() as the class and index are owned by the View.  From an impl standpoint, it would make the definition of LevelDB's view quite a bit more complicated, and it would require work in InMemoryView as well -- I'd need to pass down the containing hash of indexed-values->entity, rather than just the entities (locally referred to as elements).  The other downside is that you're using a \"View\" to mutate....\r\n\r\nAnother approach would be to use 'values' as you suggested with some commentary to clear up what we mean by values in the parameter and call the methods something like removeAllIndexedValues() and (internally) indexedValueFromEntity() or some such.\r\n\r\nThoughts?\r\n",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-16T14:42:01Z",
    "diffHunk": "@@ -126,64 +132,144 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>)data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      ConcurrentMap<Comparable<Object>, T> data;\n+      Predicate<? super T> filter;\n+      int count = 0;\n+\n+      CountingRemoveIfForEach(\n+          ConcurrentMap<Comparable<Object>, T> data,\n+          Predicate<? super T> filter) {\n+        this.data = data;\n+        this.filter = filter;\n+      }\n+\n+      public void accept(Comparable<Object> key, T value) {\n+        // To address https://bugs.openjdk.java.net/browse/JDK-8078645 which affects remove() on\n+        // all iterators of concurrent maps, and specifically makes countingRemoveIf difficult to\n+        // implement correctly against the values() iterator, we use forEach instead....\n+        if (filter.test(value)) {\n+          if (data.remove(key, value)) {\n+            count++;\n+          }\n+        }\n+      }\n+    }\n \n     private final KVTypeInfo ti;\n     private final KVTypeInfo.Accessor naturalKey;\n-    private final ConcurrentMap<Comparable<Object>, Object> data;\n-\n-    private int size;\n+    private final ConcurrentMap<Comparable<Object>, T> data;\n \n-    private InstanceList(Class<?> type) throws Exception {\n-      this.ti = new KVTypeInfo(type);\n+    private InstanceList(Class<?> klass) {\n+      this.ti = new KVTypeInfo(klass);\n       this.naturalKey = ti.getAccessor(KVIndex.NATURAL_INDEX_NAME);\n       this.data = new ConcurrentHashMap<>();\n-      this.size = 0;\n     }\n \n     KVTypeInfo.Accessor getIndexAccessor(String indexName) {\n       return ti.getAccessor(indexName);\n     }\n \n-    public Object get(Object key) {\n+    // Note: removeIf returns a boolean if any element has been removed.\n+    // While debugging this code, it was handy to have the count of elements\n+    // removed, rather than an indicator of whether something has been\n+    // removed, and a count is no more complicated than a boolean so I've\n+    // retained that behavior here, although there is no current requirement.\n+    @SuppressWarnings(\"unchecked\")\n+    int countingRemoveAllByKeys(String index, Collection keys) {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I very much believe that there might be very confusing terminology in this code. I went back and forth on implementation and interfaces a ton of times before reaching something I was happy with, and by that time I didn't really bother with the internal naming of things so much.\r\n\r\nBut here we're talking about a new method in a \"public\" interface (not this particular line, but the new method in `KVStore`), so better be a little bit more careful. And IMO index values are not keys, so \"removeByKeys\" is a little weird. Maybe \"removeByIndexValues\" is clearer.",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-16T16:36:41Z",
    "diffHunk": "@@ -126,64 +132,144 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>)data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      ConcurrentMap<Comparable<Object>, T> data;\n+      Predicate<? super T> filter;\n+      int count = 0;\n+\n+      CountingRemoveIfForEach(\n+          ConcurrentMap<Comparable<Object>, T> data,\n+          Predicate<? super T> filter) {\n+        this.data = data;\n+        this.filter = filter;\n+      }\n+\n+      public void accept(Comparable<Object> key, T value) {\n+        // To address https://bugs.openjdk.java.net/browse/JDK-8078645 which affects remove() on\n+        // all iterators of concurrent maps, and specifically makes countingRemoveIf difficult to\n+        // implement correctly against the values() iterator, we use forEach instead....\n+        if (filter.test(value)) {\n+          if (data.remove(key, value)) {\n+            count++;\n+          }\n+        }\n+      }\n+    }\n \n     private final KVTypeInfo ti;\n     private final KVTypeInfo.Accessor naturalKey;\n-    private final ConcurrentMap<Comparable<Object>, Object> data;\n-\n-    private int size;\n+    private final ConcurrentMap<Comparable<Object>, T> data;\n \n-    private InstanceList(Class<?> type) throws Exception {\n-      this.ti = new KVTypeInfo(type);\n+    private InstanceList(Class<?> klass) {\n+      this.ti = new KVTypeInfo(klass);\n       this.naturalKey = ti.getAccessor(KVIndex.NATURAL_INDEX_NAME);\n       this.data = new ConcurrentHashMap<>();\n-      this.size = 0;\n     }\n \n     KVTypeInfo.Accessor getIndexAccessor(String indexName) {\n       return ti.getAccessor(indexName);\n     }\n \n-    public Object get(Object key) {\n+    // Note: removeIf returns a boolean if any element has been removed.\n+    // While debugging this code, it was handy to have the count of elements\n+    // removed, rather than an indicator of whether something has been\n+    // removed, and a count is no more complicated than a boolean so I've\n+    // retained that behavior here, although there is no current requirement.\n+    @SuppressWarnings(\"unchecked\")\n+    int countingRemoveAllByKeys(String index, Collection keys) {"
  }, {
    "author": {
      "login": "davidnavas"
    },
    "body": "\"so better be a little bit more careful\" - strongly agree.  I'll try removeAllByIndexValues (slight merging of our proposals) -- it's a little bit of a word salad, but nothing better really strikes me.  Thanks!",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-16T16:42:46Z",
    "diffHunk": "@@ -126,64 +132,144 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>)data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      ConcurrentMap<Comparable<Object>, T> data;\n+      Predicate<? super T> filter;\n+      int count = 0;\n+\n+      CountingRemoveIfForEach(\n+          ConcurrentMap<Comparable<Object>, T> data,\n+          Predicate<? super T> filter) {\n+        this.data = data;\n+        this.filter = filter;\n+      }\n+\n+      public void accept(Comparable<Object> key, T value) {\n+        // To address https://bugs.openjdk.java.net/browse/JDK-8078645 which affects remove() on\n+        // all iterators of concurrent maps, and specifically makes countingRemoveIf difficult to\n+        // implement correctly against the values() iterator, we use forEach instead....\n+        if (filter.test(value)) {\n+          if (data.remove(key, value)) {\n+            count++;\n+          }\n+        }\n+      }\n+    }\n \n     private final KVTypeInfo ti;\n     private final KVTypeInfo.Accessor naturalKey;\n-    private final ConcurrentMap<Comparable<Object>, Object> data;\n-\n-    private int size;\n+    private final ConcurrentMap<Comparable<Object>, T> data;\n \n-    private InstanceList(Class<?> type) throws Exception {\n-      this.ti = new KVTypeInfo(type);\n+    private InstanceList(Class<?> klass) {\n+      this.ti = new KVTypeInfo(klass);\n       this.naturalKey = ti.getAccessor(KVIndex.NATURAL_INDEX_NAME);\n       this.data = new ConcurrentHashMap<>();\n-      this.size = 0;\n     }\n \n     KVTypeInfo.Accessor getIndexAccessor(String indexName) {\n       return ti.getAccessor(indexName);\n     }\n \n-    public Object get(Object key) {\n+    // Note: removeIf returns a boolean if any element has been removed.\n+    // While debugging this code, it was handy to have the count of elements\n+    // removed, rather than an indicator of whether something has been\n+    // removed, and a count is no more complicated than a boolean so I've\n+    // retained that behavior here, although there is no current requirement.\n+    @SuppressWarnings(\"unchecked\")\n+    int countingRemoveAllByKeys(String index, Collection keys) {"
  }],
  "prId": 24616
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Similar thing, `key` sounds like the wrong word here.",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-15T23:45:26Z",
    "diffHunk": "@@ -126,64 +132,144 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>)data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      ConcurrentMap<Comparable<Object>, T> data;\n+      Predicate<? super T> filter;\n+      int count = 0;\n+\n+      CountingRemoveIfForEach(\n+          ConcurrentMap<Comparable<Object>, T> data,\n+          Predicate<? super T> filter) {\n+        this.data = data;\n+        this.filter = filter;\n+      }\n+\n+      public void accept(Comparable<Object> key, T value) {\n+        // To address https://bugs.openjdk.java.net/browse/JDK-8078645 which affects remove() on\n+        // all iterators of concurrent maps, and specifically makes countingRemoveIf difficult to\n+        // implement correctly against the values() iterator, we use forEach instead....\n+        if (filter.test(value)) {\n+          if (data.remove(key, value)) {\n+            count++;\n+          }\n+        }\n+      }\n+    }\n \n     private final KVTypeInfo ti;\n     private final KVTypeInfo.Accessor naturalKey;\n-    private final ConcurrentMap<Comparable<Object>, Object> data;\n-\n-    private int size;\n+    private final ConcurrentMap<Comparable<Object>, T> data;\n \n-    private InstanceList(Class<?> type) throws Exception {\n-      this.ti = new KVTypeInfo(type);\n+    private InstanceList(Class<?> klass) {\n+      this.ti = new KVTypeInfo(klass);\n       this.naturalKey = ti.getAccessor(KVIndex.NATURAL_INDEX_NAME);\n       this.data = new ConcurrentHashMap<>();\n-      this.size = 0;\n     }\n \n     KVTypeInfo.Accessor getIndexAccessor(String indexName) {\n       return ti.getAccessor(indexName);\n     }\n \n-    public Object get(Object key) {\n+    // Note: removeIf returns a boolean if any element has been removed.\n+    // While debugging this code, it was handy to have the count of elements\n+    // removed, rather than an indicator of whether something has been\n+    // removed, and a count is no more complicated than a boolean so I've\n+    // retained that behavior here, although there is no current requirement.\n+    @SuppressWarnings(\"unchecked\")\n+    int countingRemoveAllByKeys(String index, Collection keys) {\n+      Predicate<? super T> filter = getPredicate(ti.getAccessor(index), keys);\n+      CountingRemoveIfForEach<T> callback = new CountingRemoveIfForEach<>(data, filter);\n+\n+      data.forEach(callback);\n+      return callback.count;\n+    }\n+\n+    public T get(Object key) {\n       return data.get(asKey(key));\n     }\n \n-    public void put(Object value) throws Exception {\n-      Preconditions.checkArgument(ti.type().equals(value.getClass()),\n-        \"Unexpected type: %s\", value.getClass());\n-      if (data.put(asKey(naturalKey.get(value)), value) == null) {\n-        size++;\n-      }\n+    public void put(T value) throws Exception {\n+      data.put(asKey(naturalKey.get(value)), value);\n     }\n \n     public void delete(Object key) {\n-      if (data.remove(asKey(key)) != null) {\n-        size--;\n-      }\n+      data.remove(asKey(key));\n     }\n \n     public int size() {\n-      return size;\n+      return data.size();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public InMemoryView<T> view() {\n+      return new InMemoryView<>(data.values(), ti);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public <T> InMemoryView<T> view(Class<T> type) {\n-      Preconditions.checkArgument(ti.type().equals(type), \"Unexpected type: %s\", type);\n-      Collection<T> all = (Collection<T>) data.values();\n-      return new InMemoryView<>(type, all, ti);\n+    private static <T> Predicate<? super T> getPredicate(\n+        KVTypeInfo.Accessor getter,\n+        Collection keys) {\n+      if (Comparable.class.isAssignableFrom(getter.getType())) {\n+        HashSet set = new HashSet(keys);\n+\n+        return (value) -> set.contains(keyFromValue(getter, value));\n+      } else {\n+        HashSet<Comparable> set = new HashSet<>(keys.size());\n+        for (Object key : keys) {\n+          set.add(asKey(key));\n+        }\n+        return (value) -> set.contains(asKey(keyFromValue(getter, value)));\n+      }\n     }\n \n+    private static Object keyFromValue(KVTypeInfo.Accessor getter, Object value) {"
  }],
  "prId": 24616
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "s/keys/values",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-17T23:13:52Z",
    "diffHunk": "@@ -126,64 +134,149 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>) data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    /**\n+     * A BiConsumer to control multi-entity removal.  We use this in a forEach rather than an\n+     * iterator because there is a bug in jdk8 which affects remove() on all concurrent map\n+     * iterators.  https://bugs.openjdk.java.net/browse/JDK-8078645\n+     */\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      private final ConcurrentMap<Comparable<Object>, T> data;\n+      private final Predicate<? super T> filter;\n+\n+      /**\n+       * Keeps a count of the number of elements removed.  This count is not currently surfaced\n+       * to clients of KVStore as Java's generic removeAll() construct returns only a boolean,\n+       * but I found it handy to have the count of elements removed while debugging; a count being\n+       * no more complicated than a boolean, I've retained that behavior here, even though there\n+       * is no current requirement.\n+       */\n+      private int count = 0;\n+\n+      CountingRemoveIfForEach(\n+          ConcurrentMap<Comparable<Object>, T> data,\n+          Predicate<? super T> filter) {\n+        this.data = data;\n+        this.filter = filter;\n+      }\n+\n+      public void accept(Comparable<Object> key, T value) {\n+        if (filter.test(value)) {\n+          if (data.remove(key, value)) {\n+            count++;\n+          }\n+        }\n+      }\n+\n+      public int count() { return count; }\n+    }\n \n     private final KVTypeInfo ti;\n     private final KVTypeInfo.Accessor naturalKey;\n-    private final ConcurrentMap<Comparable<Object>, Object> data;\n+    private final ConcurrentMap<Comparable<Object>, T> data;\n \n-    private int size;\n-\n-    private InstanceList(Class<?> type) throws Exception {\n-      this.ti = new KVTypeInfo(type);\n+    private InstanceList(Class<?> klass) {\n+      this.ti = new KVTypeInfo(klass);\n       this.naturalKey = ti.getAccessor(KVIndex.NATURAL_INDEX_NAME);\n       this.data = new ConcurrentHashMap<>();\n-      this.size = 0;\n     }\n \n     KVTypeInfo.Accessor getIndexAccessor(String indexName) {\n       return ti.getAccessor(indexName);\n     }\n \n-    public Object get(Object key) {\n+    int countingRemoveAllByIndexValues(String index, Collection<?> indexValues) {\n+      Predicate<? super T> filter = getPredicate(ti.getAccessor(index), indexValues);\n+      CountingRemoveIfForEach<T> callback = new CountingRemoveIfForEach<>(data, filter);\n+\n+      data.forEach(callback);\n+      return callback.count();\n+    }\n+\n+    public T get(Object key) {\n       return data.get(asKey(key));\n     }\n \n-    public void put(Object value) throws Exception {\n-      Preconditions.checkArgument(ti.type().equals(value.getClass()),\n-        \"Unexpected type: %s\", value.getClass());\n-      if (data.put(asKey(naturalKey.get(value)), value) == null) {\n-        size++;\n-      }\n+    public void put(T value) throws Exception {\n+      data.put(asKey(naturalKey.get(value)), value);\n     }\n \n     public void delete(Object key) {\n-      if (data.remove(asKey(key)) != null) {\n-        size--;\n-      }\n+      data.remove(asKey(key));\n     }\n \n     public int size() {\n-      return size;\n+      return data.size();\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    public <T> InMemoryView<T> view(Class<T> type) {\n-      Preconditions.checkArgument(ti.type().equals(type), \"Unexpected type: %s\", type);\n-      Collection<T> all = (Collection<T>) data.values();\n-      return new InMemoryView<>(type, all, ti);\n+    public InMemoryView<T> view() {\n+      return new InMemoryView<>(data.values(), ti);\n+    }\n+\n+    private static <T> Predicate<? super T> getPredicate(\n+        KVTypeInfo.Accessor getter,\n+        Collection<?> keys) {"
  }],
  "prId": 24616
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`InMemoryView<?>`?",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-17T23:14:20Z",
    "diffHunk": "@@ -126,64 +134,149 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>) data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    /**\n+     * A BiConsumer to control multi-entity removal.  We use this in a forEach rather than an\n+     * iterator because there is a bug in jdk8 which affects remove() on all concurrent map\n+     * iterators.  https://bugs.openjdk.java.net/browse/JDK-8078645\n+     */\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      private final ConcurrentMap<Comparable<Object>, T> data;\n+      private final Predicate<? super T> filter;\n+\n+      /**\n+       * Keeps a count of the number of elements removed.  This count is not currently surfaced\n+       * to clients of KVStore as Java's generic removeAll() construct returns only a boolean,\n+       * but I found it handy to have the count of elements removed while debugging; a count being\n+       * no more complicated than a boolean, I've retained that behavior here, even though there\n+       * is no current requirement.\n+       */\n+      private int count = 0;\n+\n+      CountingRemoveIfForEach(\n+          ConcurrentMap<Comparable<Object>, T> data,\n+          Predicate<? super T> filter) {\n+        this.data = data;\n+        this.filter = filter;\n+      }\n+\n+      public void accept(Comparable<Object> key, T value) {\n+        if (filter.test(value)) {\n+          if (data.remove(key, value)) {\n+            count++;\n+          }\n+        }\n+      }\n+\n+      public int count() { return count; }\n+    }\n \n     private final KVTypeInfo ti;\n     private final KVTypeInfo.Accessor naturalKey;\n-    private final ConcurrentMap<Comparable<Object>, Object> data;\n+    private final ConcurrentMap<Comparable<Object>, T> data;\n \n-    private int size;\n-\n-    private InstanceList(Class<?> type) throws Exception {\n-      this.ti = new KVTypeInfo(type);\n+    private InstanceList(Class<?> klass) {\n+      this.ti = new KVTypeInfo(klass);\n       this.naturalKey = ti.getAccessor(KVIndex.NATURAL_INDEX_NAME);\n       this.data = new ConcurrentHashMap<>();\n-      this.size = 0;\n     }\n \n     KVTypeInfo.Accessor getIndexAccessor(String indexName) {\n       return ti.getAccessor(indexName);\n     }\n \n-    public Object get(Object key) {\n+    int countingRemoveAllByIndexValues(String index, Collection<?> indexValues) {\n+      Predicate<? super T> filter = getPredicate(ti.getAccessor(index), indexValues);\n+      CountingRemoveIfForEach<T> callback = new CountingRemoveIfForEach<>(data, filter);\n+\n+      data.forEach(callback);\n+      return callback.count();\n+    }\n+\n+    public T get(Object key) {\n       return data.get(asKey(key));\n     }\n \n-    public void put(Object value) throws Exception {\n-      Preconditions.checkArgument(ti.type().equals(value.getClass()),\n-        \"Unexpected type: %s\", value.getClass());\n-      if (data.put(asKey(naturalKey.get(value)), value) == null) {\n-        size++;\n-      }\n+    public void put(T value) throws Exception {\n+      data.put(asKey(naturalKey.get(value)), value);\n     }\n \n     public void delete(Object key) {\n-      if (data.remove(asKey(key)) != null) {\n-        size--;\n-      }\n+      data.remove(asKey(key));\n     }\n \n     public int size() {\n-      return size;\n+      return data.size();\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    public <T> InMemoryView<T> view(Class<T> type) {\n-      Preconditions.checkArgument(ti.type().equals(type), \"Unexpected type: %s\", type);\n-      Collection<T> all = (Collection<T>) data.values();\n-      return new InMemoryView<>(type, all, ti);\n+    public InMemoryView<T> view() {\n+      return new InMemoryView<>(data.values(), ti);\n+    }\n+\n+    private static <T> Predicate<? super T> getPredicate(\n+        KVTypeInfo.Accessor getter,\n+        Collection<?> keys) {\n+      if (Comparable.class.isAssignableFrom(getter.getType())) {\n+        HashSet<?> set = new HashSet<>(keys);\n+\n+        return (value) -> set.contains(indexValueForEntity(getter, value));\n+      } else {\n+        HashSet<Comparable> set = new HashSet<>(keys.size());\n+        for (Object key : keys) {\n+          set.add(asKey(key));\n+        }\n+        return (value) -> set.contains(asKey(indexValueForEntity(getter, value)));\n+      }\n     }\n \n+    private static Object indexValueForEntity(KVTypeInfo.Accessor getter, Object entity) {\n+      try {\n+        return getter.get(entity);\n+      } catch (ReflectiveOperationException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n   }\n \n   private static class InMemoryView<T> extends KVStoreView<T> {\n+    private static final InMemoryView EMPTY_VIEW ="
  }],
  "prId": 24616
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Did you try to use the `getPredicate` stuff in this class too? Seems like it could save some computation.",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-20T20:14:30Z",
    "diffHunk": "@@ -248,16 +337,16 @@ private int compare(T e1, T e2, KVTypeInfo.Accessor getter) {\n           diff = compare(e1, natural, natural.get(e2));\n         }\n         return diff;\n-      } catch (Exception e) {\n-        throw Throwables.propagate(e);\n+      } catch (ReflectiveOperationException e) {\n+        throw new RuntimeException(e);\n       }\n     }\n \n     private int compare(T e1, KVTypeInfo.Accessor getter, Object v2) {\n       try {\n         return asKey(getter.get(e1)).compareTo(asKey(v2));"
  }, {
    "author": {
      "login": "davidnavas"
    },
    "body": "I have not attempted to apply the basic trick in getPredicate (of calling or not calling asKey() depending on whether the index requires it).  I agree that there might be a win there, but the application seems difficult and unlikely to yield clear code.  getPredicate() is doing two things -- it's converting a Collection into a Set as well as converting all the entries through asKey as necessary, AND it's removing the necessity of calling getClass.isArray when it isn't.  \r\n\r\nThere appear three basic times where this strategy would be useful -- during copyElements when parent is defined, and during iteration when first and/or last are defined.  Well, I don't see a contract about when first or last can be changed wrt when an iteration is started or running, so I'm a little worried about modifying that code, and I'm not sure what the usecases are for parents.  But let's assume that first and last are actually fixed during iteration (it seems bad that it is not), and I'm willing to make changes to the parent code blind ....  Presumably I'd want a set of compare() routines that took a Comparable as the second argument (the second argument being fixed locally to asKey(first|last|parent)) with two potential names -- one that would call asKey and one that wouldn't.  I'm blanking on ideas for names.  Ideas?\r\n\r\nWhat I'll do is create the \"dumb\" version of this compare call, and either we'll revert because we want to allow first and last to be modified during iteration, or we'll come up with some good names for dealing with the other half of the asKey calls.  Or we'll decide that the getClass.isArray calls for only one side of the compare isn't so bad.\r\n",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-20T22:36:12Z",
    "diffHunk": "@@ -248,16 +337,16 @@ private int compare(T e1, T e2, KVTypeInfo.Accessor getter) {\n           diff = compare(e1, natural, natural.get(e2));\n         }\n         return diff;\n-      } catch (Exception e) {\n-        throw Throwables.propagate(e);\n+      } catch (ReflectiveOperationException e) {\n+        throw new RuntimeException(e);\n       }\n     }\n \n     private int compare(T e1, KVTypeInfo.Accessor getter, Object v2) {\n       try {\n         return asKey(getter.get(e1)).compareTo(asKey(v2));"
  }],
  "prId": 24616
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "final",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-21T17:08:35Z",
    "diffHunk": "@@ -126,64 +134,149 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();",
    "line": 128
  }],
  "prId": 24616
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`@Override`",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-21T17:09:10Z",
    "diffHunk": "@@ -126,64 +134,149 @@ public void close() {\n     return (Comparable<Object>) in;\n   }\n \n-  private static class InstanceList {\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> KVStoreView<T> emptyView() {\n+    return (InMemoryView<T>) InMemoryView.EMPTY_VIEW;\n+  }\n+\n+  /**\n+   * Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\n+   * class of type T to an InstanceList of type T.\n+   */\n+  private static class InMemoryLists {\n+    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> InstanceList<T> get(Class<T> type) {\n+      return (InstanceList<T>) data.get(type);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void write(T value) throws Exception {\n+      InstanceList<T> list =\n+        (InstanceList<T>) data.computeIfAbsent(value.getClass(), InstanceList::new);\n+      list.put(value);\n+    }\n+\n+    public void clear() {\n+      data.clear();\n+    }\n+  }\n+\n+  private static class InstanceList<T> {\n+\n+    /**\n+     * A BiConsumer to control multi-entity removal.  We use this in a forEach rather than an\n+     * iterator because there is a bug in jdk8 which affects remove() on all concurrent map\n+     * iterators.  https://bugs.openjdk.java.net/browse/JDK-8078645\n+     */\n+    private static class CountingRemoveIfForEach<T> implements BiConsumer<Comparable<Object>, T> {\n+      private final ConcurrentMap<Comparable<Object>, T> data;\n+      private final Predicate<? super T> filter;\n+\n+      /**\n+       * Keeps a count of the number of elements removed.  This count is not currently surfaced\n+       * to clients of KVStore as Java's generic removeAll() construct returns only a boolean,\n+       * but I found it handy to have the count of elements removed while debugging; a count being\n+       * no more complicated than a boolean, I've retained that behavior here, even though there\n+       * is no current requirement.\n+       */\n+      private int count = 0;\n+\n+      CountingRemoveIfForEach(\n+          ConcurrentMap<Comparable<Object>, T> data,\n+          Predicate<? super T> filter) {\n+        this.data = data;\n+        this.filter = filter;\n+      }\n+\n+      public void accept(Comparable<Object> key, T value) {",
    "line": 174
  }],
  "prId": 24616
}]