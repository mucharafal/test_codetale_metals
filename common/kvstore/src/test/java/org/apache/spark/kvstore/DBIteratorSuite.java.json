[{
  "comments": [{
    "author": {
      "login": "jsoltren"
    },
    "body": "Why the + 1? Does it have special meaning or are you trying to avoid <= ?",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-05-26T17:59:34Z",
    "diffHunk": "@@ -0,0 +1,498 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Random;\n+\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+public abstract class DBIteratorSuite {\n+\n+  private static final int MIN_ENTRIES = 42;\n+  private static final int MAX_ENTRIES = 1024;\n+  private static final Random RND = new Random();\n+\n+  private static List<CustomType1> allEntries;\n+  private static List<CustomType1> clashingEntries;\n+  private static KVStore db;\n+\n+  private static interface BaseComparator extends Comparator<CustomType1> {\n+    /**\n+     * Returns a comparator that falls back to natural order if this comparator's ordering\n+     * returns equality for two elements. Used to mimic how the index sorts things internally.\n+     */\n+    default BaseComparator fallback() {\n+      return (t1, t2) -> {\n+        int result = BaseComparator.this.compare(t1, t2);\n+        if (result != 0) {\n+          return result;\n+        }\n+\n+        return t1.key.compareTo(t2.key);\n+      };\n+    }\n+\n+    /** Reverses the order of this comparator. */\n+    default BaseComparator reverse() {\n+      return (t1, t2) -> -BaseComparator.this.compare(t1, t2);\n+    }\n+  }\n+\n+  private static final BaseComparator NATURAL_ORDER = (t1, t2) -> t1.key.compareTo(t2.key);\n+  private static final BaseComparator REF_INDEX_ORDER = (t1, t2) -> t1.id.compareTo(t2.id);\n+  private static final BaseComparator COPY_INDEX_ORDER = (t1, t2) -> t1.name.compareTo(t2.name);\n+  private static final BaseComparator NUMERIC_INDEX_ORDER = (t1, t2) -> t1.num - t2.num;\n+  private static final BaseComparator CHILD_INDEX_ORDER = (t1, t2) -> t1.child.compareTo(t2.child);\n+\n+  /**\n+   * Implementations should override this method; it is called only once, before all tests are\n+   * run. Any state can be safely stored in static variables and cleaned up in a @AfterClass\n+   * handler.\n+   */\n+  protected abstract KVStore createStore() throws Exception;\n+\n+  @AfterClass\n+  public static void cleanupData() throws Exception {\n+    allEntries = null;\n+    db = null;\n+  }\n+\n+  @Before\n+  public void setup() throws Exception {\n+    if (db != null) {\n+      return;\n+    }\n+\n+    db = createStore();\n+\n+    int count = RND.nextInt(MAX_ENTRIES) + MIN_ENTRIES;\n+\n+    // Instead of generating sequential IDs, generate random unique IDs to avoid the insertion\n+    // order matching the natural ordering. Just in case.\n+    boolean[] usedIDs = new boolean[count];\n+\n+    allEntries = new ArrayList<>(count);\n+    for (int i = 0; i < count; i++) {\n+      CustomType1 t = new CustomType1();\n+\n+      int id;\n+      do {\n+        id = RND.nextInt(count);\n+      } while (usedIDs[id]);\n+\n+      usedIDs[id] = true;\n+      t.key = \"key\" + id;\n+      t.id = \"id\" + i;\n+      t.name = \"name\" + RND.nextInt(MAX_ENTRIES);\n+      t.num = RND.nextInt(MAX_ENTRIES);\n+      t.child = \"child\" + (i % MIN_ENTRIES);\n+      allEntries.add(t);\n+      db.write(t);\n+    }\n+\n+    // Pick the first generated value, and forcefully create a few entries that will clash\n+    // with the indexed values (id and name), to make sure the index behaves correctly when\n+    // multiple entities are indexed by the same value.\n+    //\n+    // This also serves as a test for the test code itself, to make sure it's sorting indices\n+    // the same way the store is expected to.\n+    CustomType1 first = allEntries.get(0);\n+    clashingEntries = new ArrayList<>();\n+    for (int i = 0; i < RND.nextInt(MIN_ENTRIES) + 1; i++) {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Because `Random.nextInt(int)` can return 0.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-05-26T18:22:37Z",
    "diffHunk": "@@ -0,0 +1,498 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Random;\n+\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+public abstract class DBIteratorSuite {\n+\n+  private static final int MIN_ENTRIES = 42;\n+  private static final int MAX_ENTRIES = 1024;\n+  private static final Random RND = new Random();\n+\n+  private static List<CustomType1> allEntries;\n+  private static List<CustomType1> clashingEntries;\n+  private static KVStore db;\n+\n+  private static interface BaseComparator extends Comparator<CustomType1> {\n+    /**\n+     * Returns a comparator that falls back to natural order if this comparator's ordering\n+     * returns equality for two elements. Used to mimic how the index sorts things internally.\n+     */\n+    default BaseComparator fallback() {\n+      return (t1, t2) -> {\n+        int result = BaseComparator.this.compare(t1, t2);\n+        if (result != 0) {\n+          return result;\n+        }\n+\n+        return t1.key.compareTo(t2.key);\n+      };\n+    }\n+\n+    /** Reverses the order of this comparator. */\n+    default BaseComparator reverse() {\n+      return (t1, t2) -> -BaseComparator.this.compare(t1, t2);\n+    }\n+  }\n+\n+  private static final BaseComparator NATURAL_ORDER = (t1, t2) -> t1.key.compareTo(t2.key);\n+  private static final BaseComparator REF_INDEX_ORDER = (t1, t2) -> t1.id.compareTo(t2.id);\n+  private static final BaseComparator COPY_INDEX_ORDER = (t1, t2) -> t1.name.compareTo(t2.name);\n+  private static final BaseComparator NUMERIC_INDEX_ORDER = (t1, t2) -> t1.num - t2.num;\n+  private static final BaseComparator CHILD_INDEX_ORDER = (t1, t2) -> t1.child.compareTo(t2.child);\n+\n+  /**\n+   * Implementations should override this method; it is called only once, before all tests are\n+   * run. Any state can be safely stored in static variables and cleaned up in a @AfterClass\n+   * handler.\n+   */\n+  protected abstract KVStore createStore() throws Exception;\n+\n+  @AfterClass\n+  public static void cleanupData() throws Exception {\n+    allEntries = null;\n+    db = null;\n+  }\n+\n+  @Before\n+  public void setup() throws Exception {\n+    if (db != null) {\n+      return;\n+    }\n+\n+    db = createStore();\n+\n+    int count = RND.nextInt(MAX_ENTRIES) + MIN_ENTRIES;\n+\n+    // Instead of generating sequential IDs, generate random unique IDs to avoid the insertion\n+    // order matching the natural ordering. Just in case.\n+    boolean[] usedIDs = new boolean[count];\n+\n+    allEntries = new ArrayList<>(count);\n+    for (int i = 0; i < count; i++) {\n+      CustomType1 t = new CustomType1();\n+\n+      int id;\n+      do {\n+        id = RND.nextInt(count);\n+      } while (usedIDs[id]);\n+\n+      usedIDs[id] = true;\n+      t.key = \"key\" + id;\n+      t.id = \"id\" + i;\n+      t.name = \"name\" + RND.nextInt(MAX_ENTRIES);\n+      t.num = RND.nextInt(MAX_ENTRIES);\n+      t.child = \"child\" + (i % MIN_ENTRIES);\n+      allEntries.add(t);\n+      db.write(t);\n+    }\n+\n+    // Pick the first generated value, and forcefully create a few entries that will clash\n+    // with the indexed values (id and name), to make sure the index behaves correctly when\n+    // multiple entities are indexed by the same value.\n+    //\n+    // This also serves as a test for the test code itself, to make sure it's sorting indices\n+    // the same way the store is expected to.\n+    CustomType1 first = allEntries.get(0);\n+    clashingEntries = new ArrayList<>();\n+    for (int i = 0; i < RND.nextInt(MIN_ENTRIES) + 1; i++) {"
  }],
  "prId": 17902
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "I know this doesn't really matter, but this is O(n^2), listing the ids and then using https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#shuffle-java.util.List-java.util.Random- would be O(n)",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-06-01T15:47:11Z",
    "diffHunk": "@@ -0,0 +1,500 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Random;\n+\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+public abstract class DBIteratorSuite {\n+\n+  private static final int MIN_ENTRIES = 42;\n+  private static final int MAX_ENTRIES = 1024;\n+  private static final Random RND = new Random();\n+\n+  private static List<CustomType1> allEntries;\n+  private static List<CustomType1> clashingEntries;\n+  private static KVStore db;\n+\n+  private static interface BaseComparator extends Comparator<CustomType1> {\n+    /**\n+     * Returns a comparator that falls back to natural order if this comparator's ordering\n+     * returns equality for two elements. Used to mimic how the index sorts things internally.\n+     */\n+    default BaseComparator fallback() {\n+      return (t1, t2) -> {\n+        int result = BaseComparator.this.compare(t1, t2);\n+        if (result != 0) {\n+          return result;\n+        }\n+\n+        return t1.key.compareTo(t2.key);\n+      };\n+    }\n+\n+    /** Reverses the order of this comparator. */\n+    default BaseComparator reverse() {\n+      return (t1, t2) -> -BaseComparator.this.compare(t1, t2);\n+    }\n+  }\n+\n+  private static final BaseComparator NATURAL_ORDER = (t1, t2) -> t1.key.compareTo(t2.key);\n+  private static final BaseComparator REF_INDEX_ORDER = (t1, t2) -> t1.id.compareTo(t2.id);\n+  private static final BaseComparator COPY_INDEX_ORDER = (t1, t2) -> t1.name.compareTo(t2.name);\n+  private static final BaseComparator NUMERIC_INDEX_ORDER = (t1, t2) -> t1.num - t2.num;\n+  private static final BaseComparator CHILD_INDEX_ORDER = (t1, t2) -> t1.child.compareTo(t2.child);\n+\n+  /**\n+   * Implementations should override this method; it is called only once, before all tests are\n+   * run. Any state can be safely stored in static variables and cleaned up in a @AfterClass\n+   * handler.\n+   */\n+  protected abstract KVStore createStore() throws Exception;\n+\n+  @AfterClass\n+  public static void cleanupData() throws Exception {\n+    allEntries = null;\n+    db = null;\n+  }\n+\n+  @Before\n+  public void setup() throws Exception {\n+    if (db != null) {\n+      return;\n+    }\n+\n+    db = createStore();\n+\n+    int count = RND.nextInt(MAX_ENTRIES) + MIN_ENTRIES;\n+\n+    // Instead of generating sequential IDs, generate random unique IDs to avoid the insertion\n+    // order matching the natural ordering. Just in case.\n+    boolean[] usedIDs = new boolean[count];\n+\n+    allEntries = new ArrayList<>(count);\n+    for (int i = 0; i < count; i++) {\n+      CustomType1 t = new CustomType1();\n+\n+      int id;\n+      do {\n+        id = RND.nextInt(count);\n+      } while (usedIDs[id]);"
  }],
  "prId": 17902
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "for later debugging, it would be helpful to log the random generator seed here.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-06-02T16:58:14Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Random;\n+\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+public abstract class DBIteratorSuite {\n+\n+  private static final int MIN_ENTRIES = 42;\n+  private static final int MAX_ENTRIES = 1024;\n+  private static final Random RND = new Random();\n+\n+  private static List<CustomType1> allEntries;\n+  private static List<CustomType1> clashingEntries;\n+  private static KVStore db;\n+\n+  private static interface BaseComparator extends Comparator<CustomType1> {\n+    /**\n+     * Returns a comparator that falls back to natural order if this comparator's ordering\n+     * returns equality for two elements. Used to mimic how the index sorts things internally.\n+     */\n+    default BaseComparator fallback() {\n+      return (t1, t2) -> {\n+        int result = BaseComparator.this.compare(t1, t2);\n+        if (result != 0) {\n+          return result;\n+        }\n+\n+        return t1.key.compareTo(t2.key);\n+      };\n+    }\n+\n+    /** Reverses the order of this comparator. */\n+    default BaseComparator reverse() {\n+      return (t1, t2) -> -BaseComparator.this.compare(t1, t2);\n+    }\n+  }\n+\n+  private static final BaseComparator NATURAL_ORDER = (t1, t2) -> t1.key.compareTo(t2.key);\n+  private static final BaseComparator REF_INDEX_ORDER = (t1, t2) -> t1.id.compareTo(t2.id);\n+  private static final BaseComparator COPY_INDEX_ORDER = (t1, t2) -> t1.name.compareTo(t2.name);\n+  private static final BaseComparator NUMERIC_INDEX_ORDER = (t1, t2) -> t1.num - t2.num;\n+  private static final BaseComparator CHILD_INDEX_ORDER = (t1, t2) -> t1.child.compareTo(t2.child);\n+\n+  /**\n+   * Implementations should override this method; it is called only once, before all tests are\n+   * run. Any state can be safely stored in static variables and cleaned up in a @AfterClass\n+   * handler.\n+   */\n+  protected abstract KVStore createStore() throws Exception;\n+\n+  @AfterClass\n+  public static void cleanupData() throws Exception {\n+    allEntries = null;\n+    db = null;\n+  }\n+\n+  @Before\n+  public void setup() throws Exception {\n+    if (db != null) {",
    "line": 103
  }],
  "prId": 17902
}]