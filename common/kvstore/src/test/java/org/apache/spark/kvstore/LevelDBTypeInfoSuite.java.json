[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "you also require that there is one element with a bare `@KVIndex`, with no `value`, to get a natural index, right?  I think its worth adding a case w/ valid `@KVIndex` but all have values.",
    "commit": "53d7d57196317ef406875f73d6e806f3b7956ee7",
    "createdAt": "2017-06-01T16:04:26Z",
    "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.kvstore;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+public class LevelDBTypeInfoSuite {\n+\n+  @Test\n+  public void testIndexAnnotation() throws Exception {\n+    KVTypeInfo ti = new KVTypeInfo(CustomType1.class);\n+    assertEquals(5, ti.indices().count());\n+\n+    CustomType1 t1 = new CustomType1();\n+    t1.key = \"key\";\n+    t1.id = \"id\";\n+    t1.name = \"name\";\n+    t1.num = 42;\n+    t1.child = \"child\";\n+\n+    assertEquals(t1.key, ti.getIndexValue(KVIndex.NATURAL_INDEX_NAME, t1));\n+    assertEquals(t1.id, ti.getIndexValue(\"id\", t1));\n+    assertEquals(t1.name, ti.getIndexValue(\"name\", t1));\n+    assertEquals(t1.num, ti.getIndexValue(\"int\", t1));\n+    assertEquals(t1.child, ti.getIndexValue(\"child\", t1));\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void testNoNaturalIndex() throws Exception {\n+    newTypeInfo(NoNaturalIndex.class);\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void testDuplicateIndex() throws Exception {\n+    newTypeInfo(DuplicateIndex.class);\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void testEmptyIndexName() throws Exception {\n+    newTypeInfo(EmptyIndexName.class);\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void testIllegalIndexName() throws Exception {\n+    newTypeInfo(IllegalIndexName.class);\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void testIllegalIndexMethod() throws Exception {\n+    newTypeInfo(IllegalIndexMethod.class);\n+  }\n+\n+  @Test\n+  public void testKeyClashes() throws Exception {\n+    LevelDBTypeInfo ti = newTypeInfo(CustomType1.class);\n+\n+    CustomType1 t1 = new CustomType1();\n+    t1.key = \"key1\";\n+    t1.name = \"a\";\n+\n+    CustomType1 t2 = new CustomType1();\n+    t2.key = \"key2\";\n+    t2.name = \"aa\";\n+\n+    CustomType1 t3 = new CustomType1();\n+    t3.key = \"key3\";\n+    t3.name = \"aaa\";\n+\n+    // Make sure entries with conflicting names are sorted correctly.\n+    assertBefore(ti.index(\"name\").entityKey(null, t1), ti.index(\"name\").entityKey(null, t2));\n+    assertBefore(ti.index(\"name\").entityKey(null, t1), ti.index(\"name\").entityKey(null, t3));\n+    assertBefore(ti.index(\"name\").entityKey(null, t2), ti.index(\"name\").entityKey(null, t3));\n+  }\n+\n+  @Test\n+  public void testNumEncoding() throws Exception {\n+    LevelDBTypeInfo.Index idx = newTypeInfo(CustomType1.class).indices().iterator().next();\n+\n+    assertEquals(\"+=00000001\", new String(idx.toKey(1), UTF_8));\n+    assertEquals(\"+=00000010\", new String(idx.toKey(16), UTF_8));\n+    assertEquals(\"+=7fffffff\", new String(idx.toKey(Integer.MAX_VALUE), UTF_8));\n+\n+    assertBefore(idx.toKey(1), idx.toKey(2));\n+    assertBefore(idx.toKey(-1), idx.toKey(2));\n+    assertBefore(idx.toKey(-11), idx.toKey(2));\n+    assertBefore(idx.toKey(-11), idx.toKey(-1));\n+    assertBefore(idx.toKey(1), idx.toKey(11));\n+    assertBefore(idx.toKey(Integer.MIN_VALUE), idx.toKey(Integer.MAX_VALUE));\n+\n+    assertBefore(idx.toKey(1L), idx.toKey(2L));\n+    assertBefore(idx.toKey(-1L), idx.toKey(2L));\n+    assertBefore(idx.toKey(Long.MIN_VALUE), idx.toKey(Long.MAX_VALUE));\n+\n+    assertBefore(idx.toKey((short) 1), idx.toKey((short) 2));\n+    assertBefore(idx.toKey((short) -1), idx.toKey((short) 2));\n+    assertBefore(idx.toKey(Short.MIN_VALUE), idx.toKey(Short.MAX_VALUE));\n+\n+    assertBefore(idx.toKey((byte) 1), idx.toKey((byte) 2));\n+    assertBefore(idx.toKey((byte) -1), idx.toKey((byte) 2));\n+    assertBefore(idx.toKey(Byte.MIN_VALUE), idx.toKey(Byte.MAX_VALUE));\n+\n+    byte prefix = LevelDBTypeInfo.ENTRY_PREFIX;\n+    assertSame(new byte[] { prefix, LevelDBTypeInfo.FALSE }, idx.toKey(false));\n+    assertSame(new byte[] { prefix, LevelDBTypeInfo.TRUE }, idx.toKey(true));\n+  }\n+\n+  @Test\n+  public void testArrayIndices() throws Exception {\n+    LevelDBTypeInfo.Index idx = newTypeInfo(CustomType1.class).indices().iterator().next();\n+\n+    assertBefore(idx.toKey(new String[] { \"str1\" }), idx.toKey(new String[] { \"str2\" }));\n+    assertBefore(idx.toKey(new String[] { \"str1\", \"str2\" }),\n+      idx.toKey(new String[] { \"str1\", \"str3\" }));\n+\n+    assertBefore(idx.toKey(new int[] { 1 }), idx.toKey(new int[] { 2 }));\n+    assertBefore(idx.toKey(new int[] { 1, 2 }), idx.toKey(new int[] { 1, 3 }));\n+  }\n+\n+  private LevelDBTypeInfo newTypeInfo(Class<?> type) throws Exception {\n+    return new LevelDBTypeInfo(null, type, type.getName().getBytes(UTF_8));\n+  }\n+\n+  private void assertBefore(byte[] key1, byte[] key2) {\n+    assertBefore(new String(key1, UTF_8), new String(key2, UTF_8));\n+  }\n+\n+  private void assertBefore(String str1, String str2) {\n+    assertTrue(String.format(\"%s < %s failed\", str1, str2), str1.compareTo(str2) < 0);\n+  }\n+\n+  private void assertSame(byte[] key1, byte[] key2) {\n+    assertEquals(new String(key1, UTF_8), new String(key2, UTF_8));\n+  }\n+\n+  public static class NoNaturalIndex {\n+\n+    public String id;\n+\n+  }",
    "line": 162
  }],
  "prId": 17902
}]