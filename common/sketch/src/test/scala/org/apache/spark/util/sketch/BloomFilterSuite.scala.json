[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i think you also need to test fpp - otherwise this test will always be true if after merging all the bits are set.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-24T04:48:14Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](\n+      typeName: String, numItems: Int)(itemGenerator: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGenerator(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedInsertions`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }\n+\n+      // Also check the actual fpp is not significantly higher than we expected.\n+      val actualFpp = errorCount.toDouble / (numItems - numInsertion)\n+      // Skip error count that is too small.\n+      assert(errorCount < 50 || actualFpp - fpp < 0.001)\n+    }\n+  }\n+\n+  def testMergeInPlace[T: ClassTag](typeName: String)(itemGenerator: Random => T): Unit = {\n+    test(s\"mergeInPlace - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+\n+      val items1 = Array.fill(1000)(itemGenerator(r))\n+      val items2 = Array.fill(1000)(itemGenerator(r))\n+\n+      val filter1 = BloomFilter.create(1000)\n+      items1.foreach(filter1.put)\n+\n+      val filter2 = BloomFilter.create(1000)\n+      items2.foreach(filter2.put)\n+\n+      filter1.mergeInPlace(filter2)\n+\n+      items1.foreach(i => assert(filter1.mightContain(i)))\n+      items2.foreach(i => assert(filter1.mightContain(i)))"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "I think it's OK to use `allItems.take(numInsertion).foreach(filter.put)` for simplicity if this code path doesn't slow down test execution too much.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T19:56:47Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Similarly, `assert(allItems.take(numInsertion).forall(filter.mightContain))` for simplicity.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T19:57:59Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "``` scala\nval errorCount = allItems.drop(numInsertion).count(filter.mightContain)\n```\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T19:59:21Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedNumItems`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Does the 0.001 here stand for epsilon? Should we wrap `0.03 - filter1.expectedFpp()` with `Math.abs()`?\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T21:44:59Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedNumItems`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }\n+\n+      // Also check the actual fpp is not significantly higher than we expected.\n+      val actualFpp = errorCount.toDouble / (numItems - numInsertion)\n+      // Skip error count that is too small.\n+      assert(errorCount < 50 || actualFpp - fpp < 0.001)\n+    }\n+  }\n+\n+  def testMergeInPlace[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"mergeInPlace - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+\n+      val items1 = Array.fill(numItems / 2)(itemGen(r))\n+      val items2 = Array.fill(numItems / 2)(itemGen(r))\n+\n+      val filter1 = BloomFilter.create(numItems)\n+      items1.foreach(filter1.put)\n+\n+      val filter2 = BloomFilter.create(numItems)\n+      items2.foreach(filter2.put)\n+\n+      filter1.mergeInPlace(filter2)\n+\n+      // After merge, `filter1` has `numItems` items which doesn't exceed `expectedNumItems`, so the\n+      // `expectedFpp` should not be significantly higher than the default one: 3%\n+      // Skip byte type as it has too little distinct values.\n+      assert(typeName == \"Byte\" || 0.03 - filter1.expectedFpp() < 0.001)"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Do we still need to special case \"Byte\" here when we already have `numItems` (it's 200 for Byte type)?\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T21:52:34Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedNumItems`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }\n+\n+      // Also check the actual fpp is not significantly higher than we expected.\n+      val actualFpp = errorCount.toDouble / (numItems - numInsertion)\n+      // Skip error count that is too small.\n+      assert(errorCount < 50 || actualFpp - fpp < 0.001)\n+    }\n+  }\n+\n+  def testMergeInPlace[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"mergeInPlace - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+\n+      val items1 = Array.fill(numItems / 2)(itemGen(r))\n+      val items2 = Array.fill(numItems / 2)(itemGen(r))\n+\n+      val filter1 = BloomFilter.create(numItems)\n+      items1.foreach(filter1.put)\n+\n+      val filter2 = BloomFilter.create(numItems)\n+      items2.foreach(filter2.put)\n+\n+      filter1.mergeInPlace(filter2)\n+\n+      // After merge, `filter1` has `numItems` items which doesn't exceed `expectedNumItems`, so the\n+      // `expectedFpp` should not be significantly higher than the default one: 3%\n+      // Skip byte type as it has too little distinct values.\n+      assert(typeName == \"Byte\" || 0.03 - filter1.expectedFpp() < 0.001)"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Would be nice to make 0.01 a private static constant, e.g. `EPSILON`.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T21:53:36Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedNumItems`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }\n+\n+      // Also check the actual fpp is not significantly higher than we expected.\n+      val actualFpp = errorCount.toDouble / (numItems - numInsertion)\n+      // Skip error count that is too small.\n+      assert(errorCount < 50 || actualFpp - fpp < 0.001)\n+    }\n+  }\n+\n+  def testMergeInPlace[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"mergeInPlace - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+\n+      val items1 = Array.fill(numItems / 2)(itemGen(r))\n+      val items2 = Array.fill(numItems / 2)(itemGen(r))\n+\n+      val filter1 = BloomFilter.create(numItems)\n+      items1.foreach(filter1.put)\n+\n+      val filter2 = BloomFilter.create(numItems)\n+      items2.foreach(filter2.put)\n+\n+      filter1.mergeInPlace(filter2)\n+\n+      // After merge, `filter1` has `numItems` items which doesn't exceed `expectedNumItems`, so the\n+      // `expectedFpp` should not be significantly higher than the default one: 3%\n+      // Skip byte type as it has too little distinct values.\n+      assert(typeName == \"Byte\" || 0.03 - filter1.expectedFpp() < 0.001)"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Actually we should swap `0.03` and `filter1.expectedFpp()` here.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T22:29:07Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedNumItems`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }\n+\n+      // Also check the actual fpp is not significantly higher than we expected.\n+      val actualFpp = errorCount.toDouble / (numItems - numInsertion)\n+      // Skip error count that is too small.\n+      assert(errorCount < 50 || actualFpp - fpp < 0.001)\n+    }\n+  }\n+\n+  def testMergeInPlace[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"mergeInPlace - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+\n+      val items1 = Array.fill(numItems / 2)(itemGen(r))\n+      val items2 = Array.fill(numItems / 2)(itemGen(r))\n+\n+      val filter1 = BloomFilter.create(numItems)\n+      items1.foreach(filter1.put)\n+\n+      val filter2 = BloomFilter.create(numItems)\n+      items2.foreach(filter2.put)\n+\n+      filter1.mergeInPlace(filter2)\n+\n+      // After merge, `filter1` has `numItems` items which doesn't exceed `expectedNumItems`, so the\n+      // `expectedFpp` should not be significantly higher than the default one: 3%\n+      // Skip byte type as it has too little distinct values.\n+      assert(typeName == \"Byte\" || 0.03 - filter1.expectedFpp() < 0.001)"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Wrap with `Math.abs()`?\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T21:45:19Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedNumItems`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }\n+\n+      // Also check the actual fpp is not significantly higher than we expected.\n+      val actualFpp = errorCount.toDouble / (numItems - numInsertion)\n+      // Skip error count that is too small.\n+      assert(errorCount < 50 || actualFpp - fpp < 0.001)"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "Should we? I think `actualFpp < fpp` is a good thing...  It means the bloom filter performs better than user expected.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T22:02:17Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedNumItems`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }\n+\n+      // Also check the actual fpp is not significantly higher than we expected.\n+      val actualFpp = errorCount.toDouble / (numItems - numInsertion)\n+      // Skip error count that is too small.\n+      assert(errorCount < 50 || actualFpp - fpp < 0.001)"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Why do we need to skip small error count? Does it violate the second predicate?\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T22:14:53Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedNumItems`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }\n+\n+      // Also check the actual fpp is not significantly higher than we expected.\n+      val actualFpp = errorCount.toDouble / (numItems - numInsertion)\n+      // Skip error count that is too small.\n+      assert(errorCount < 50 || actualFpp - fpp < 0.001)"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Ah alright. `Math.abs` is unnecessary here.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T22:18:42Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedNumItems`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }\n+\n+      // Also check the actual fpp is not significantly higher than we expected.\n+      val actualFpp = errorCount.toDouble / (numItems - numInsertion)\n+      // Skip error count that is too small.\n+      assert(errorCount < 50 || actualFpp - fpp < 0.001)"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Would be nice to add another test case for incompatible merge (like [this one](https://github.com/apache/spark/pull/10893/files#diff-2d63de5e2683ff296c8b0fb058cc995dR138)).\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T22:26:21Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BloomFilterSuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  def testAccuracy[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"accuracy - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+      val fpp = 0.05\n+      val numInsertion = numItems / 10\n+\n+      val allItems = Array.fill(numItems)(itemGen(r))\n+\n+      val filter = BloomFilter.create(numInsertion, fpp)\n+\n+      // insert first `numInsertion` items.\n+      var i = 0\n+      while (i < numInsertion) {\n+        filter.put(allItems(i))\n+        i += 1\n+      }\n+\n+      i = 0\n+      while (i < numInsertion) {\n+        // false negative is not allowed.\n+        assert(filter.mightContain(allItems(i)))\n+        i += 1\n+      }\n+\n+      // The number of inserted items doesn't exceed `expectedNumItems`, so the `expectedFpp`\n+      // should not be significantly higher than the one we passed in to create this bloom filter.\n+      assert(filter.expectedFpp() - fpp < 0.001)\n+\n+      var errorCount = 0\n+      while (i < numItems) {\n+        if (filter.mightContain(allItems(i))) errorCount += 1\n+        i += 1\n+      }\n+\n+      // Also check the actual fpp is not significantly higher than we expected.\n+      val actualFpp = errorCount.toDouble / (numItems - numInsertion)\n+      // Skip error count that is too small.\n+      assert(errorCount < 50 || actualFpp - fpp < 0.001)\n+    }\n+  }\n+\n+  def testMergeInPlace[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    test(s\"mergeInPlace - $typeName\") {\n+      // use a fixed seed to make the test predictable.\n+      val r = new Random(37)\n+\n+      val items1 = Array.fill(numItems / 2)(itemGen(r))\n+      val items2 = Array.fill(numItems / 2)(itemGen(r))\n+\n+      val filter1 = BloomFilter.create(numItems)\n+      items1.foreach(filter1.put)\n+\n+      val filter2 = BloomFilter.create(numItems)\n+      items2.foreach(filter2.put)\n+\n+      filter1.mergeInPlace(filter2)\n+\n+      // After merge, `filter1` has `numItems` items which doesn't exceed `expectedNumItems`, so the\n+      // `expectedFpp` should not be significantly higher than the default one: 3%\n+      // Skip byte type as it has too little distinct values.\n+      assert(typeName == \"Byte\" || 0.03 - filter1.expectedFpp() < 0.001)\n+\n+      items1.foreach(i => assert(filter1.mightContain(i)))\n+      items2.foreach(i => assert(filter1.mightContain(i)))\n+    }\n+  }\n+\n+  def testItemType[T: ClassTag](typeName: String, numItems: Int)(itemGen: Random => T): Unit = {\n+    testAccuracy[T](typeName, numItems)(itemGen)\n+    testMergeInPlace[T](typeName, numItems)(itemGen)\n+  }\n+\n+  testItemType[Byte](\"Byte\", 200) { _.nextInt().toByte }\n+\n+  testItemType[Short](\"Short\", 1000) { _.nextInt().toShort }\n+\n+  testItemType[Int](\"Int\", 100000) { _.nextInt() }\n+\n+  testItemType[Long](\"Long\", 100000) { _.nextLong() }\n+\n+  testItemType[String](\"String\", 100000) { r => r.nextString(r.nextInt(512)) }\n+}"
  }],
  "prId": 10883
}]