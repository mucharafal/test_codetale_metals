[{
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Use `===` instead of `==` for better error message.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T21:54:57Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BitArraySuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  test(\"error case when create BitArray\") {\n+    intercept[IllegalArgumentException](new BitArray(0))\n+    intercept[IllegalArgumentException](new BitArray(64L * Integer.MAX_VALUE + 1))\n+  }\n+\n+  test(\"bitSize\") {\n+    assert(new BitArray(64).bitSize() == 64)\n+    // BitArray is word-aligned, so 65~128 bits need 2 long to store, which is 128 bits.\n+    assert(new BitArray(65).bitSize() == 128)\n+    assert(new BitArray(127).bitSize() == 128)\n+    assert(new BitArray(128).bitSize() == 128)",
    "line": 36
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "this no longer matters in new versions of scalatest\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-26T01:55:47Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BitArraySuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  test(\"error case when create BitArray\") {\n+    intercept[IllegalArgumentException](new BitArray(0))\n+    intercept[IllegalArgumentException](new BitArray(64L * Integer.MAX_VALUE + 1))\n+  }\n+\n+  test(\"bitSize\") {\n+    assert(new BitArray(64).bitSize() == 64)\n+    // BitArray is word-aligned, so 65~128 bits need 2 long to store, which is 128 bits.\n+    assert(new BitArray(65).bitSize() == 128)\n+    assert(new BitArray(127).bitSize() == 128)\n+    assert(new BitArray(128).bitSize() == 128)",
    "line": 36
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "`foreach` instead of `map`?\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T22:11:13Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BitArraySuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  test(\"error case when create BitArray\") {\n+    intercept[IllegalArgumentException](new BitArray(0))\n+    intercept[IllegalArgumentException](new BitArray(64L * Integer.MAX_VALUE + 1))\n+  }\n+\n+  test(\"bitSize\") {\n+    assert(new BitArray(64).bitSize() == 64)\n+    // BitArray is word-aligned, so 65~128 bits need 2 long to store, which is 128 bits.\n+    assert(new BitArray(65).bitSize() == 128)\n+    assert(new BitArray(127).bitSize() == 128)\n+    assert(new BitArray(128).bitSize() == 128)\n+  }\n+\n+  test(\"set\") {\n+    val bitArray = new BitArray(64)\n+    assert(bitArray.set(1))\n+    // Only returns true if the bit changed.\n+    assert(!bitArray.set(1))\n+    assert(bitArray.set(2))\n+  }\n+\n+  test(\"normal operation\") {\n+    // use a fixed seed to make the test predictable.\n+    val r = new Random(37)\n+\n+    val bitArray = new BitArray(320)\n+    val indexes = (1 to 100).map(_ => r.nextInt(320).toLong).distinct\n+\n+    indexes.map(bitArray.set)\n+    indexes.foreach(i => assert(bitArray.get(i)))\n+    assert(bitArray.cardinality() == indexes.length)\n+  }\n+\n+  test(\"merge\") {\n+    // use a fixed seed to make the test predictable.\n+    val r = new Random(37)\n+\n+    val bitArray1 = new BitArray(64 * 6)\n+    val bitArray2 = new BitArray(64 * 6)\n+\n+    val indexes1 = (1 to 100).map(_ => r.nextInt(64 * 6).toLong).distinct\n+    val indexes2 = (1 to 100).map(_ => r.nextInt(64 * 6).toLong).distinct\n+\n+    indexes1.map(bitArray1.set)\n+    indexes2.map(bitArray2.set)"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "`===` instead of `==`.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T22:13:50Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BitArraySuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  test(\"error case when create BitArray\") {\n+    intercept[IllegalArgumentException](new BitArray(0))\n+    intercept[IllegalArgumentException](new BitArray(64L * Integer.MAX_VALUE + 1))\n+  }\n+\n+  test(\"bitSize\") {\n+    assert(new BitArray(64).bitSize() == 64)\n+    // BitArray is word-aligned, so 65~128 bits need 2 long to store, which is 128 bits.\n+    assert(new BitArray(65).bitSize() == 128)\n+    assert(new BitArray(127).bitSize() == 128)\n+    assert(new BitArray(128).bitSize() == 128)\n+  }\n+\n+  test(\"set\") {\n+    val bitArray = new BitArray(64)\n+    assert(bitArray.set(1))\n+    // Only returns true if the bit changed.\n+    assert(!bitArray.set(1))\n+    assert(bitArray.set(2))\n+  }\n+\n+  test(\"normal operation\") {\n+    // use a fixed seed to make the test predictable.\n+    val r = new Random(37)\n+\n+    val bitArray = new BitArray(320)\n+    val indexes = (1 to 100).map(_ => r.nextInt(320).toLong).distinct\n+\n+    indexes.map(bitArray.set)\n+    indexes.foreach(i => assert(bitArray.get(i)))\n+    assert(bitArray.cardinality() == indexes.length)\n+  }\n+\n+  test(\"merge\") {\n+    // use a fixed seed to make the test predictable.\n+    val r = new Random(37)\n+\n+    val bitArray1 = new BitArray(64 * 6)\n+    val bitArray2 = new BitArray(64 * 6)\n+\n+    val indexes1 = (1 to 100).map(_ => r.nextInt(64 * 6).toLong).distinct\n+    val indexes2 = (1 to 100).map(_ => r.nextInt(64 * 6).toLong).distinct\n+\n+    indexes1.map(bitArray1.set)\n+    indexes2.map(bitArray2.set)\n+\n+    bitArray1.putAll(bitArray2)\n+    indexes1.foreach(i => assert(bitArray1.get(i)))\n+    indexes2.foreach(i => assert(bitArray1.get(i)))\n+    assert(bitArray1.cardinality() == (indexes1 ++ indexes2).distinct.length)",
    "line": 75
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "I remember they are same now, cc @andrewor14 \n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T23:09:00Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BitArraySuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  test(\"error case when create BitArray\") {\n+    intercept[IllegalArgumentException](new BitArray(0))\n+    intercept[IllegalArgumentException](new BitArray(64L * Integer.MAX_VALUE + 1))\n+  }\n+\n+  test(\"bitSize\") {\n+    assert(new BitArray(64).bitSize() == 64)\n+    // BitArray is word-aligned, so 65~128 bits need 2 long to store, which is 128 bits.\n+    assert(new BitArray(65).bitSize() == 128)\n+    assert(new BitArray(127).bitSize() == 128)\n+    assert(new BitArray(128).bitSize() == 128)\n+  }\n+\n+  test(\"set\") {\n+    val bitArray = new BitArray(64)\n+    assert(bitArray.set(1))\n+    // Only returns true if the bit changed.\n+    assert(!bitArray.set(1))\n+    assert(bitArray.set(2))\n+  }\n+\n+  test(\"normal operation\") {\n+    // use a fixed seed to make the test predictable.\n+    val r = new Random(37)\n+\n+    val bitArray = new BitArray(320)\n+    val indexes = (1 to 100).map(_ => r.nextInt(320).toLong).distinct\n+\n+    indexes.map(bitArray.set)\n+    indexes.foreach(i => assert(bitArray.get(i)))\n+    assert(bitArray.cardinality() == indexes.length)\n+  }\n+\n+  test(\"merge\") {\n+    // use a fixed seed to make the test predictable.\n+    val r = new Random(37)\n+\n+    val bitArray1 = new BitArray(64 * 6)\n+    val bitArray2 = new BitArray(64 * 6)\n+\n+    val indexes1 = (1 to 100).map(_ => r.nextInt(64 * 6).toLong).distinct\n+    val indexes2 = (1 to 100).map(_ => r.nextInt(64 * 6).toLong).distinct\n+\n+    indexes1.map(bitArray1.set)\n+    indexes2.map(bitArray2.set)\n+\n+    bitArray1.putAll(bitArray2)\n+    indexes1.foreach(i => assert(bitArray1.get(i)))\n+    indexes2.foreach(i => assert(bitArray1.get(i)))\n+    assert(bitArray1.cardinality() == (indexes1 ++ indexes2).distinct.length)",
    "line": 75
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "see http://www.scalatest.org/user_guide/using_assertions\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-25T23:13:14Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch\n+\n+import scala.util.Random\n+\n+import org.scalatest.FunSuite // scalastyle:ignore funsuite\n+\n+class BitArraySuite extends FunSuite { // scalastyle:ignore funsuite\n+\n+  test(\"error case when create BitArray\") {\n+    intercept[IllegalArgumentException](new BitArray(0))\n+    intercept[IllegalArgumentException](new BitArray(64L * Integer.MAX_VALUE + 1))\n+  }\n+\n+  test(\"bitSize\") {\n+    assert(new BitArray(64).bitSize() == 64)\n+    // BitArray is word-aligned, so 65~128 bits need 2 long to store, which is 128 bits.\n+    assert(new BitArray(65).bitSize() == 128)\n+    assert(new BitArray(127).bitSize() == 128)\n+    assert(new BitArray(128).bitSize() == 128)\n+  }\n+\n+  test(\"set\") {\n+    val bitArray = new BitArray(64)\n+    assert(bitArray.set(1))\n+    // Only returns true if the bit changed.\n+    assert(!bitArray.set(1))\n+    assert(bitArray.set(2))\n+  }\n+\n+  test(\"normal operation\") {\n+    // use a fixed seed to make the test predictable.\n+    val r = new Random(37)\n+\n+    val bitArray = new BitArray(320)\n+    val indexes = (1 to 100).map(_ => r.nextInt(320).toLong).distinct\n+\n+    indexes.map(bitArray.set)\n+    indexes.foreach(i => assert(bitArray.get(i)))\n+    assert(bitArray.cardinality() == indexes.length)\n+  }\n+\n+  test(\"merge\") {\n+    // use a fixed seed to make the test predictable.\n+    val r = new Random(37)\n+\n+    val bitArray1 = new BitArray(64 * 6)\n+    val bitArray2 = new BitArray(64 * 6)\n+\n+    val indexes1 = (1 to 100).map(_ => r.nextInt(64 * 6).toLong).distinct\n+    val indexes2 = (1 to 100).map(_ => r.nextInt(64 * 6).toLong).distinct\n+\n+    indexes1.map(bitArray1.set)\n+    indexes2.map(bitArray2.set)\n+\n+    bitArray1.putAll(bitArray2)\n+    indexes1.foreach(i => assert(bitArray1.get(i)))\n+    indexes2.foreach(i => assert(bitArray1.get(i)))\n+    assert(bitArray1.cardinality() == (indexes1 ++ indexes2).distinct.length)",
    "line": 75
  }],
  "prId": 10883
}]