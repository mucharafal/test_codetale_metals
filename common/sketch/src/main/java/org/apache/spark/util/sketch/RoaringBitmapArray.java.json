[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Probably a dumb question but why do we need an array of bitmaps? I thought RoaringBitmap was a BitArray counterpart?\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T11:27:50Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {"
  }, {
    "author": {
      "login": "ponkin"
    },
    "body": "Unfortunately, RoaringBitmap supports only int indexes [javadoc](http://www.javadoc.io/doc/org.roaringbitmap/RoaringBitmap/0.6.27). Since we need to support bloom filters with size more than Int.MaxValue(BitArray supported 64*IntMaxValue) I decided to partition bloom filter with RoaringBitmap[]. Now Bloom filter can be Long.MaxValue large in size(number of bits).\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T12:10:48Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Hm, I see: https://github.com/RoaringBitmap/RoaringBitmap/issues/109\nI wonder if it's worth using RoaringBitmap then, but, of course making the improvements we want from RB would take work too, and, removing code helps.\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T12:14:19Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {"
  }, {
    "author": {
      "login": "ponkin"
    },
    "body": "well, the main point of this improvement is to save memory - now even filters with few elements acquire space needed for full bloom filter. With this improvement bloom filter size will increase as we insert values in it. \n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T12:20:06Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "It's certainly worth documenting this in the scaladoc BTW, why the class has to exist.\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T13:52:48Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {"
  }],
  "prId": 15917
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Small style things: space before braces, and after casts, as in a few lines above. Spaces around elements of a for loop, as below.\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T13:53:25Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {\n+\n+    private final RoaringBitmap[] data;\n+    private long bitCount; // number of 1`s in bitset\n+    private final long numBits; // total number of available bits\n+\n+    private static int numOfBuckets(long numBits) {\n+        if (numBits <= 0) {\n+            throw new IllegalArgumentException(\"numBits must be positive, but got \" + numBits);\n+        }\n+        return (int) Math.ceil(numBits / (double)Integer.MAX_VALUE);\n+    }\n+\n+    private static RoaringBitmap[] initialVector(int numOfBuckets){"
  }],
  "prId": 15917
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "2 space indent everywhere\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T13:53:52Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {\n+\n+    private final RoaringBitmap[] data;\n+    private long bitCount; // number of 1`s in bitset\n+    private final long numBits; // total number of available bits\n+\n+    private static int numOfBuckets(long numBits) {\n+        if (numBits <= 0) {\n+            throw new IllegalArgumentException(\"numBits must be positive, but got \" + numBits);\n+        }\n+        return (int) Math.ceil(numBits / (double)Integer.MAX_VALUE);\n+    }\n+\n+    private static RoaringBitmap[] initialVector(int numOfBuckets){\n+        RoaringBitmap[] vector = new RoaringBitmap[numOfBuckets];\n+        for(int i = 0;i<numOfBuckets;i++){\n+            vector[i] = new RoaringBitmap();\n+        }\n+        return vector;\n+    }\n+\n+    RoaringBitmapArray(long numBits) {\n+        this(initialVector(numOfBuckets(numBits)), numBits);\n+    }\n+\n+    private RoaringBitmapArray(RoaringBitmap[] data, long numBits) {\n+        this.data = data;\n+        this.numBits = numBits;\n+        long bitCount = 0;\n+        for (RoaringBitmap bucket : data) {\n+            bitCount += bucket.getCardinality();\n+        }\n+        this.bitCount = bitCount;\n+    }\n+\n+    /** Returns true if the bit changed value. */\n+    boolean set(long index) {\n+        int bucketNum = (int)(index / Integer.MAX_VALUE);\n+        int bitIdx = (int)(index % Integer.MAX_VALUE);\n+        if(!data[bucketNum].contains(bitIdx)) {\n+            data[bucketNum].add(bitIdx);\n+            bitCount++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean get(long index) {\n+        int bucketNum = (int)(index / Integer.MAX_VALUE);\n+        int bitIdx = (int) (index % Integer.MAX_VALUE);\n+        return data[bucketNum].contains(bitIdx);\n+    }\n+\n+    /** Number of bits */\n+    long bitSize() {\n+        return numBits;"
  }],
  "prId": 15917
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Is it worth incorporating bitCount, numBits? it's not wrong to omit them, but might be didier.\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T13:55:40Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {\n+\n+    private final RoaringBitmap[] data;\n+    private long bitCount; // number of 1`s in bitset\n+    private final long numBits; // total number of available bits\n+\n+    private static int numOfBuckets(long numBits) {\n+        if (numBits <= 0) {\n+            throw new IllegalArgumentException(\"numBits must be positive, but got \" + numBits);\n+        }\n+        return (int) Math.ceil(numBits / (double)Integer.MAX_VALUE);\n+    }\n+\n+    private static RoaringBitmap[] initialVector(int numOfBuckets){\n+        RoaringBitmap[] vector = new RoaringBitmap[numOfBuckets];\n+        for(int i = 0;i<numOfBuckets;i++){\n+            vector[i] = new RoaringBitmap();\n+        }\n+        return vector;\n+    }\n+\n+    RoaringBitmapArray(long numBits) {\n+        this(initialVector(numOfBuckets(numBits)), numBits);\n+    }\n+\n+    private RoaringBitmapArray(RoaringBitmap[] data, long numBits) {\n+        this.data = data;\n+        this.numBits = numBits;\n+        long bitCount = 0;\n+        for (RoaringBitmap bucket : data) {\n+            bitCount += bucket.getCardinality();\n+        }\n+        this.bitCount = bitCount;\n+    }\n+\n+    /** Returns true if the bit changed value. */\n+    boolean set(long index) {\n+        int bucketNum = (int)(index / Integer.MAX_VALUE);\n+        int bitIdx = (int)(index % Integer.MAX_VALUE);\n+        if(!data[bucketNum].contains(bitIdx)) {\n+            data[bucketNum].add(bitIdx);\n+            bitCount++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean get(long index) {\n+        int bucketNum = (int)(index / Integer.MAX_VALUE);\n+        int bitIdx = (int) (index % Integer.MAX_VALUE);\n+        return data[bucketNum].contains(bitIdx);\n+    }\n+\n+    /** Number of bits */\n+    long bitSize() {\n+        return numBits;\n+    }\n+\n+    /** Number of set bits (1s) */\n+    long cardinality() {\n+        return bitCount;\n+    }\n+\n+    /** Combines the two RoaringBitmapArray using bitwise OR. */\n+    void putAll(RoaringBitmapArray bitmap) {\n+        assert data.length == bitmap.data.length : \"RoaringBitmapArray`s must be of equal length when merging\";\n+        long mergedBitCount = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            data[i].or(bitmap.data[i]);\n+            mergedBitCount += data[i].getCardinality();\n+        }\n+        this.bitCount = mergedBitCount;\n+    }\n+\n+    void writeTo(DataOutputStream out) throws IOException {\n+        out.writeInt(data.length);\n+        out.writeLong(numBits);\n+        for (RoaringBitmap datum : data) {\n+            datum.runOptimize();\n+            datum.serialize(out);\n+        }\n+    }\n+\n+    static RoaringBitmapArray readFrom(DataInputStream in) throws IOException {\n+        int numOfBuckets = in.readInt();\n+        long numBits = in.readLong();\n+        RoaringBitmap[] data = new RoaringBitmap[numOfBuckets];\n+        for (int i = 0; i < numOfBuckets; i++) {\n+            data[i] = new RoaringBitmap();\n+            data[i].deserialize(in);\n+        }\n+        return new RoaringBitmapArray(data, numBits);\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) return true;\n+        if (other == null || !(other instanceof RoaringBitmapArray)) return false;\n+        RoaringBitmapArray that = (RoaringBitmapArray) other;\n+        return (this.bitCount == that.bitCount) &&\n+                (this.numBits == that.numBits) &&\n+                 Arrays.equals(data, that.data);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Arrays.hashCode(data);"
  }],
  "prId": 15917
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Use braces, newline for return\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T13:55:46Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {\n+\n+    private final RoaringBitmap[] data;\n+    private long bitCount; // number of 1`s in bitset\n+    private final long numBits; // total number of available bits\n+\n+    private static int numOfBuckets(long numBits) {\n+        if (numBits <= 0) {\n+            throw new IllegalArgumentException(\"numBits must be positive, but got \" + numBits);\n+        }\n+        return (int) Math.ceil(numBits / (double)Integer.MAX_VALUE);\n+    }\n+\n+    private static RoaringBitmap[] initialVector(int numOfBuckets){\n+        RoaringBitmap[] vector = new RoaringBitmap[numOfBuckets];\n+        for(int i = 0;i<numOfBuckets;i++){\n+            vector[i] = new RoaringBitmap();\n+        }\n+        return vector;\n+    }\n+\n+    RoaringBitmapArray(long numBits) {\n+        this(initialVector(numOfBuckets(numBits)), numBits);\n+    }\n+\n+    private RoaringBitmapArray(RoaringBitmap[] data, long numBits) {\n+        this.data = data;\n+        this.numBits = numBits;\n+        long bitCount = 0;\n+        for (RoaringBitmap bucket : data) {\n+            bitCount += bucket.getCardinality();\n+        }\n+        this.bitCount = bitCount;\n+    }\n+\n+    /** Returns true if the bit changed value. */\n+    boolean set(long index) {\n+        int bucketNum = (int)(index / Integer.MAX_VALUE);\n+        int bitIdx = (int)(index % Integer.MAX_VALUE);\n+        if(!data[bucketNum].contains(bitIdx)) {\n+            data[bucketNum].add(bitIdx);\n+            bitCount++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean get(long index) {\n+        int bucketNum = (int)(index / Integer.MAX_VALUE);\n+        int bitIdx = (int) (index % Integer.MAX_VALUE);\n+        return data[bucketNum].contains(bitIdx);\n+    }\n+\n+    /** Number of bits */\n+    long bitSize() {\n+        return numBits;\n+    }\n+\n+    /** Number of set bits (1s) */\n+    long cardinality() {\n+        return bitCount;\n+    }\n+\n+    /** Combines the two RoaringBitmapArray using bitwise OR. */\n+    void putAll(RoaringBitmapArray bitmap) {\n+        assert data.length == bitmap.data.length : \"RoaringBitmapArray`s must be of equal length when merging\";\n+        long mergedBitCount = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            data[i].or(bitmap.data[i]);\n+            mergedBitCount += data[i].getCardinality();\n+        }\n+        this.bitCount = mergedBitCount;\n+    }\n+\n+    void writeTo(DataOutputStream out) throws IOException {\n+        out.writeInt(data.length);\n+        out.writeLong(numBits);\n+        for (RoaringBitmap datum : data) {\n+            datum.runOptimize();\n+            datum.serialize(out);\n+        }\n+    }\n+\n+    static RoaringBitmapArray readFrom(DataInputStream in) throws IOException {\n+        int numOfBuckets = in.readInt();\n+        long numBits = in.readLong();\n+        RoaringBitmap[] data = new RoaringBitmap[numOfBuckets];\n+        for (int i = 0; i < numOfBuckets; i++) {\n+            data[i] = new RoaringBitmap();\n+            data[i].deserialize(in);\n+        }\n+        return new RoaringBitmapArray(data, numBits);\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) return true;\n+        if (other == null || !(other instanceof RoaringBitmapArray)) return false;"
  }],
  "prId": 15917
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "4-space continuation indents\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T13:55:57Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {\n+\n+    private final RoaringBitmap[] data;\n+    private long bitCount; // number of 1`s in bitset\n+    private final long numBits; // total number of available bits\n+\n+    private static int numOfBuckets(long numBits) {\n+        if (numBits <= 0) {\n+            throw new IllegalArgumentException(\"numBits must be positive, but got \" + numBits);\n+        }\n+        return (int) Math.ceil(numBits / (double)Integer.MAX_VALUE);\n+    }\n+\n+    private static RoaringBitmap[] initialVector(int numOfBuckets){\n+        RoaringBitmap[] vector = new RoaringBitmap[numOfBuckets];\n+        for(int i = 0;i<numOfBuckets;i++){\n+            vector[i] = new RoaringBitmap();\n+        }\n+        return vector;\n+    }\n+\n+    RoaringBitmapArray(long numBits) {\n+        this(initialVector(numOfBuckets(numBits)), numBits);\n+    }\n+\n+    private RoaringBitmapArray(RoaringBitmap[] data, long numBits) {\n+        this.data = data;\n+        this.numBits = numBits;\n+        long bitCount = 0;\n+        for (RoaringBitmap bucket : data) {\n+            bitCount += bucket.getCardinality();\n+        }\n+        this.bitCount = bitCount;\n+    }\n+\n+    /** Returns true if the bit changed value. */\n+    boolean set(long index) {\n+        int bucketNum = (int)(index / Integer.MAX_VALUE);\n+        int bitIdx = (int)(index % Integer.MAX_VALUE);\n+        if(!data[bucketNum].contains(bitIdx)) {\n+            data[bucketNum].add(bitIdx);\n+            bitCount++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean get(long index) {\n+        int bucketNum = (int)(index / Integer.MAX_VALUE);\n+        int bitIdx = (int) (index % Integer.MAX_VALUE);\n+        return data[bucketNum].contains(bitIdx);\n+    }\n+\n+    /** Number of bits */\n+    long bitSize() {\n+        return numBits;\n+    }\n+\n+    /** Number of set bits (1s) */\n+    long cardinality() {\n+        return bitCount;\n+    }\n+\n+    /** Combines the two RoaringBitmapArray using bitwise OR. */\n+    void putAll(RoaringBitmapArray bitmap) {\n+        assert data.length == bitmap.data.length : \"RoaringBitmapArray`s must be of equal length when merging\";\n+        long mergedBitCount = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            data[i].or(bitmap.data[i]);\n+            mergedBitCount += data[i].getCardinality();\n+        }\n+        this.bitCount = mergedBitCount;\n+    }\n+\n+    void writeTo(DataOutputStream out) throws IOException {\n+        out.writeInt(data.length);\n+        out.writeLong(numBits);\n+        for (RoaringBitmap datum : data) {\n+            datum.runOptimize();\n+            datum.serialize(out);\n+        }\n+    }\n+\n+    static RoaringBitmapArray readFrom(DataInputStream in) throws IOException {\n+        int numOfBuckets = in.readInt();\n+        long numBits = in.readLong();\n+        RoaringBitmap[] data = new RoaringBitmap[numOfBuckets];\n+        for (int i = 0; i < numOfBuckets; i++) {\n+            data[i] = new RoaringBitmap();\n+            data[i].deserialize(in);\n+        }\n+        return new RoaringBitmapArray(data, numBits);\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) return true;\n+        if (other == null || !(other instanceof RoaringBitmapArray)) return false;\n+        RoaringBitmapArray that = (RoaringBitmapArray) other;\n+        return (this.bitCount == that.bitCount) &&\n+                (this.numBits == that.numBits) &&"
  }],
  "prId": 15917
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Is it worth maintaining this? it slows down paths like set; is it called frequently enough to cache?\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T13:56:55Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {\n+\n+    private final RoaringBitmap[] data;\n+    private long bitCount; // number of 1`s in bitset"
  }, {
    "author": {
      "login": "ponkin"
    },
    "body": "it is only need to calculate expectedFpp (false positive rate) which is not very frequent operation, I agree. will remove\n",
    "commit": "487da8fbd23f2d861ab10a1faf701696e9ca3967",
    "createdAt": "2016-11-17T14:25:52Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import org.roaringbitmap.RoaringBitmap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+class RoaringBitmapArray {\n+\n+    private final RoaringBitmap[] data;\n+    private long bitCount; // number of 1`s in bitset"
  }],
  "prId": 15917
}]