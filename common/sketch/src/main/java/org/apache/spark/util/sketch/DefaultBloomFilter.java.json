[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "we should be consistent in naming with the count-min sketch one, i.e. rename this BloomFilterImpl.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-24T04:33:14Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+public class DefaultBloomFilter extends BloomFilter {"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "ctor shoudl be package private (just remove public)\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-24T04:40:31Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+public class DefaultBloomFilter extends BloomFilter {\n+\n+  private final int numHashFunctions;\n+  private final BitArray bits;\n+\n+  public DefaultBloomFilter(int numHashFunctions, long numBits) {"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "is this shared with count-min sketch? maybe we can put this into a Util class used by both.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-24T04:42:05Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+public class DefaultBloomFilter extends BloomFilter {\n+\n+  private final int numHashFunctions;\n+  private final BitArray bits;\n+\n+  public DefaultBloomFilter(int numHashFunctions, long numBits) {\n+    this.numHashFunctions = numHashFunctions;\n+    this.bits = new BitArray(numBits);\n+  }\n+\n+  @Override\n+  public double expectedFpp() {\n+    return Math.pow((double) bits.bitCount() / bits.bitSize(), numHashFunctions);\n+  }\n+\n+  @Override\n+  public long bitSize() {\n+    return bits.bitSize();\n+  }\n+\n+  private static long hashObjectToLong(Object item) {"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "safeCast -> numWords?\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-24T04:43:34Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+public class DefaultBloomFilter extends BloomFilter {\n+\n+  private final int numHashFunctions;\n+  private final BitArray bits;\n+\n+  public DefaultBloomFilter(int numHashFunctions, long numBits) {\n+    this.numHashFunctions = numHashFunctions;\n+    this.bits = new BitArray(numBits);\n+  }\n+\n+  @Override\n+  public double expectedFpp() {\n+    return Math.pow((double) bits.bitCount() / bits.bitSize(), numHashFunctions);\n+  }\n+\n+  @Override\n+  public long bitSize() {\n+    return bits.bitSize();\n+  }\n+\n+  private static long hashObjectToLong(Object item) {\n+    if (item instanceof String) {\n+      try {\n+        byte[] bytes = ((String) item).getBytes(\"utf-8\");\n+        return hashBytesToLong(bytes);\n+      } catch (UnsupportedEncodingException e) {\n+        throw new RuntimeException(\"Only support utf-8 string\", e);\n+      }\n+    } else {\n+      long longValue;\n+\n+      if (item instanceof Long) {\n+        longValue = (Long) item;\n+      } else if (item instanceof Integer) {\n+        longValue = ((Integer) item).longValue();\n+      } else if (item instanceof Short) {\n+        longValue = ((Short) item).longValue();\n+      } else if (item instanceof Byte) {\n+        longValue = ((Byte) item).longValue();\n+      } else {\n+        throw new IllegalArgumentException(\n+          \"Support for \" + item.getClass().getName() + \" not implemented\"\n+        );\n+      }\n+\n+      int h1 = Murmur3_x86_32.hashLong(longValue, 0);\n+      int h2 = Murmur3_x86_32.hashLong(longValue, h1);\n+      return (((long) h1) << 32) | (h2 & 0xFFFFFFFFL);\n+    }\n+  }\n+\n+  private static long hashBytesToLong(byte[] bytes) {\n+    int h1 = Murmur3_x86_32.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, bytes.length, 0);\n+    int h2 = Murmur3_x86_32.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, bytes.length, h1);\n+    return (((long) h1) << 32) | (h2 & 0xFFFFFFFFL);\n+  }\n+\n+  @Override\n+  public boolean put(Object item) {\n+    long bitSize = bits.bitSize();\n+    long hash64 = hashObjectToLong(item);\n+    int h1 = (int) (hash64 >> 32);\n+    int h2 = (int) hash64;\n+\n+    boolean bitsChanged = false;\n+    for (int i = 1; i <= numHashFunctions; i++) {\n+      int combinedHash = h1 + (i * h2);\n+      // Flip all the bits if it's negative (guaranteed positive number)\n+      if (combinedHash < 0) {\n+        combinedHash = ~combinedHash;\n+      }\n+      bitsChanged |= bits.set(combinedHash % bitSize);\n+    }\n+    return bitsChanged;\n+  }\n+\n+  @Override\n+  public boolean mightContain(Object item) {\n+    long bitSize = bits.bitSize();\n+    long hash64 = hashObjectToLong(item);\n+    int h1 = (int) (hash64 >> 32);\n+    int h2 = (int) hash64;\n+\n+    for (int i = 1; i <= numHashFunctions; i++) {\n+      int combinedHash = h1 + (i * h2);\n+      // Flip all the bits if it's negative (guaranteed positive number)\n+      if (combinedHash < 0) {\n+        combinedHash = ~combinedHash;\n+      }\n+      if (!bits.get(combinedHash % bitSize)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean isCompatible(BloomFilter other) {\n+    if (other == null) {\n+      return false;\n+    }\n+\n+    if (!(other instanceof DefaultBloomFilter)) {\n+      return false;\n+    }\n+\n+    DefaultBloomFilter that = (DefaultBloomFilter) other;\n+    return this.bitSize() == that.bitSize() && this.numHashFunctions == that.numHashFunctions;\n+  }\n+\n+  @Override\n+  public BloomFilter mergeInPlace(BloomFilter other) {\n+    if (!isCompatible(other)) {\n+      throw new IllegalArgumentException(\"Can't merge incompatible bloom filter\");\n+    }\n+\n+    DefaultBloomFilter that = (DefaultBloomFilter) other;\n+    this.bits.putAll(that.bits);\n+    return this;\n+  }\n+\n+  static final class BitArray {\n+    final long[] data;\n+    long bitCount;\n+\n+    static int safeCast(long numBits) {"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "I'd move this out of this file and just have a BitSet class. We should have a test suite for this too.\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-24T04:45:46Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+public class DefaultBloomFilter extends BloomFilter {\n+\n+  private final int numHashFunctions;\n+  private final BitArray bits;\n+\n+  public DefaultBloomFilter(int numHashFunctions, long numBits) {\n+    this.numHashFunctions = numHashFunctions;\n+    this.bits = new BitArray(numBits);\n+  }\n+\n+  @Override\n+  public double expectedFpp() {\n+    return Math.pow((double) bits.bitCount() / bits.bitSize(), numHashFunctions);\n+  }\n+\n+  @Override\n+  public long bitSize() {\n+    return bits.bitSize();\n+  }\n+\n+  private static long hashObjectToLong(Object item) {\n+    if (item instanceof String) {\n+      try {\n+        byte[] bytes = ((String) item).getBytes(\"utf-8\");\n+        return hashBytesToLong(bytes);\n+      } catch (UnsupportedEncodingException e) {\n+        throw new RuntimeException(\"Only support utf-8 string\", e);\n+      }\n+    } else {\n+      long longValue;\n+\n+      if (item instanceof Long) {\n+        longValue = (Long) item;\n+      } else if (item instanceof Integer) {\n+        longValue = ((Integer) item).longValue();\n+      } else if (item instanceof Short) {\n+        longValue = ((Short) item).longValue();\n+      } else if (item instanceof Byte) {\n+        longValue = ((Byte) item).longValue();\n+      } else {\n+        throw new IllegalArgumentException(\n+          \"Support for \" + item.getClass().getName() + \" not implemented\"\n+        );\n+      }\n+\n+      int h1 = Murmur3_x86_32.hashLong(longValue, 0);\n+      int h2 = Murmur3_x86_32.hashLong(longValue, h1);\n+      return (((long) h1) << 32) | (h2 & 0xFFFFFFFFL);\n+    }\n+  }\n+\n+  private static long hashBytesToLong(byte[] bytes) {\n+    int h1 = Murmur3_x86_32.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, bytes.length, 0);\n+    int h2 = Murmur3_x86_32.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, bytes.length, h1);\n+    return (((long) h1) << 32) | (h2 & 0xFFFFFFFFL);\n+  }\n+\n+  @Override\n+  public boolean put(Object item) {\n+    long bitSize = bits.bitSize();\n+    long hash64 = hashObjectToLong(item);\n+    int h1 = (int) (hash64 >> 32);\n+    int h2 = (int) hash64;\n+\n+    boolean bitsChanged = false;\n+    for (int i = 1; i <= numHashFunctions; i++) {\n+      int combinedHash = h1 + (i * h2);\n+      // Flip all the bits if it's negative (guaranteed positive number)\n+      if (combinedHash < 0) {\n+        combinedHash = ~combinedHash;\n+      }\n+      bitsChanged |= bits.set(combinedHash % bitSize);\n+    }\n+    return bitsChanged;\n+  }\n+\n+  @Override\n+  public boolean mightContain(Object item) {\n+    long bitSize = bits.bitSize();\n+    long hash64 = hashObjectToLong(item);\n+    int h1 = (int) (hash64 >> 32);\n+    int h2 = (int) hash64;\n+\n+    for (int i = 1; i <= numHashFunctions; i++) {\n+      int combinedHash = h1 + (i * h2);\n+      // Flip all the bits if it's negative (guaranteed positive number)\n+      if (combinedHash < 0) {\n+        combinedHash = ~combinedHash;\n+      }\n+      if (!bits.get(combinedHash % bitSize)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean isCompatible(BloomFilter other) {\n+    if (other == null) {\n+      return false;\n+    }\n+\n+    if (!(other instanceof DefaultBloomFilter)) {\n+      return false;\n+    }\n+\n+    DefaultBloomFilter that = (DefaultBloomFilter) other;\n+    return this.bitSize() == that.bitSize() && this.numHashFunctions == that.numHashFunctions;\n+  }\n+\n+  @Override\n+  public BloomFilter mergeInPlace(BloomFilter other) {\n+    if (!isCompatible(other)) {\n+      throw new IllegalArgumentException(\"Can't merge incompatible bloom filter\");\n+    }\n+\n+    DefaultBloomFilter that = (DefaultBloomFilter) other;\n+    this.bits.putAll(that.bits);\n+    return this;\n+  }\n+\n+  static final class BitArray {"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "bitCount -> cardinality\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-24T04:46:11Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+public class DefaultBloomFilter extends BloomFilter {\n+\n+  private final int numHashFunctions;\n+  private final BitArray bits;\n+\n+  public DefaultBloomFilter(int numHashFunctions, long numBits) {\n+    this.numHashFunctions = numHashFunctions;\n+    this.bits = new BitArray(numBits);\n+  }\n+\n+  @Override\n+  public double expectedFpp() {\n+    return Math.pow((double) bits.bitCount() / bits.bitSize(), numHashFunctions);\n+  }\n+\n+  @Override\n+  public long bitSize() {\n+    return bits.bitSize();\n+  }\n+\n+  private static long hashObjectToLong(Object item) {\n+    if (item instanceof String) {\n+      try {\n+        byte[] bytes = ((String) item).getBytes(\"utf-8\");\n+        return hashBytesToLong(bytes);\n+      } catch (UnsupportedEncodingException e) {\n+        throw new RuntimeException(\"Only support utf-8 string\", e);\n+      }\n+    } else {\n+      long longValue;\n+\n+      if (item instanceof Long) {\n+        longValue = (Long) item;\n+      } else if (item instanceof Integer) {\n+        longValue = ((Integer) item).longValue();\n+      } else if (item instanceof Short) {\n+        longValue = ((Short) item).longValue();\n+      } else if (item instanceof Byte) {\n+        longValue = ((Byte) item).longValue();\n+      } else {\n+        throw new IllegalArgumentException(\n+          \"Support for \" + item.getClass().getName() + \" not implemented\"\n+        );\n+      }\n+\n+      int h1 = Murmur3_x86_32.hashLong(longValue, 0);\n+      int h2 = Murmur3_x86_32.hashLong(longValue, h1);\n+      return (((long) h1) << 32) | (h2 & 0xFFFFFFFFL);\n+    }\n+  }\n+\n+  private static long hashBytesToLong(byte[] bytes) {\n+    int h1 = Murmur3_x86_32.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, bytes.length, 0);\n+    int h2 = Murmur3_x86_32.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, bytes.length, h1);\n+    return (((long) h1) << 32) | (h2 & 0xFFFFFFFFL);\n+  }\n+\n+  @Override\n+  public boolean put(Object item) {\n+    long bitSize = bits.bitSize();\n+    long hash64 = hashObjectToLong(item);\n+    int h1 = (int) (hash64 >> 32);\n+    int h2 = (int) hash64;\n+\n+    boolean bitsChanged = false;\n+    for (int i = 1; i <= numHashFunctions; i++) {\n+      int combinedHash = h1 + (i * h2);\n+      // Flip all the bits if it's negative (guaranteed positive number)\n+      if (combinedHash < 0) {\n+        combinedHash = ~combinedHash;\n+      }\n+      bitsChanged |= bits.set(combinedHash % bitSize);\n+    }\n+    return bitsChanged;\n+  }\n+\n+  @Override\n+  public boolean mightContain(Object item) {\n+    long bitSize = bits.bitSize();\n+    long hash64 = hashObjectToLong(item);\n+    int h1 = (int) (hash64 >> 32);\n+    int h2 = (int) hash64;\n+\n+    for (int i = 1; i <= numHashFunctions; i++) {\n+      int combinedHash = h1 + (i * h2);\n+      // Flip all the bits if it's negative (guaranteed positive number)\n+      if (combinedHash < 0) {\n+        combinedHash = ~combinedHash;\n+      }\n+      if (!bits.get(combinedHash % bitSize)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean isCompatible(BloomFilter other) {\n+    if (other == null) {\n+      return false;\n+    }\n+\n+    if (!(other instanceof DefaultBloomFilter)) {\n+      return false;\n+    }\n+\n+    DefaultBloomFilter that = (DefaultBloomFilter) other;\n+    return this.bitSize() == that.bitSize() && this.numHashFunctions == that.numHashFunctions;\n+  }\n+\n+  @Override\n+  public BloomFilter mergeInPlace(BloomFilter other) {\n+    if (!isCompatible(other)) {\n+      throw new IllegalArgumentException(\"Can't merge incompatible bloom filter\");\n+    }\n+\n+    DefaultBloomFilter that = (DefaultBloomFilter) other;\n+    this.bits.putAll(that.bits);\n+    return this;\n+  }\n+\n+  static final class BitArray {\n+    final long[] data;\n+    long bitCount;\n+\n+    static int safeCast(long numBits) {\n+      long numWords = (long) Math.ceil(numBits / 64.0);\n+      assert numWords <= Integer.MAX_VALUE : \"Can't allocate enough space for \" + numBits + \" bits\";\n+      return (int) numWords;\n+    }\n+\n+    BitArray(long numBits) {\n+      this(new long[safeCast(numBits)]);\n+    }\n+\n+    BitArray(long[] data) {\n+      assert data.length > 0 : \"data length is zero!\";\n+      this.data = data;\n+      long bitCount = 0;\n+      for (long value : data) {\n+        bitCount += Long.bitCount(value);\n+      }\n+      this.bitCount = bitCount;\n+    }\n+\n+    /** Returns true if the bit changed value. */\n+    boolean set(long index) {\n+      if (!get(index)) {\n+        data[(int) (index >>> 6)] |= (1L << index);\n+        bitCount++;\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    boolean get(long index) {\n+      return (data[(int) (index >>> 6)] & (1L << index)) != 0;\n+    }\n+\n+    /** Number of bits */\n+    long bitSize() {\n+      return (long) data.length * Long.SIZE;\n+    }\n+\n+    /** Number of set bits (1s) */\n+    long bitCount() {"
  }],
  "prId": 10883
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "is this needed?\n",
    "commit": "a9a6e834834a03f36084d51041235dc7c7621ff0",
    "createdAt": "2016-01-24T04:46:22Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.sketch;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+public class DefaultBloomFilter extends BloomFilter {\n+\n+  private final int numHashFunctions;\n+  private final BitArray bits;\n+\n+  public DefaultBloomFilter(int numHashFunctions, long numBits) {\n+    this.numHashFunctions = numHashFunctions;\n+    this.bits = new BitArray(numBits);\n+  }\n+\n+  @Override\n+  public double expectedFpp() {\n+    return Math.pow((double) bits.bitCount() / bits.bitSize(), numHashFunctions);\n+  }\n+\n+  @Override\n+  public long bitSize() {\n+    return bits.bitSize();\n+  }\n+\n+  private static long hashObjectToLong(Object item) {\n+    if (item instanceof String) {\n+      try {\n+        byte[] bytes = ((String) item).getBytes(\"utf-8\");\n+        return hashBytesToLong(bytes);\n+      } catch (UnsupportedEncodingException e) {\n+        throw new RuntimeException(\"Only support utf-8 string\", e);\n+      }\n+    } else {\n+      long longValue;\n+\n+      if (item instanceof Long) {\n+        longValue = (Long) item;\n+      } else if (item instanceof Integer) {\n+        longValue = ((Integer) item).longValue();\n+      } else if (item instanceof Short) {\n+        longValue = ((Short) item).longValue();\n+      } else if (item instanceof Byte) {\n+        longValue = ((Byte) item).longValue();\n+      } else {\n+        throw new IllegalArgumentException(\n+          \"Support for \" + item.getClass().getName() + \" not implemented\"\n+        );\n+      }\n+\n+      int h1 = Murmur3_x86_32.hashLong(longValue, 0);\n+      int h2 = Murmur3_x86_32.hashLong(longValue, h1);\n+      return (((long) h1) << 32) | (h2 & 0xFFFFFFFFL);\n+    }\n+  }\n+\n+  private static long hashBytesToLong(byte[] bytes) {\n+    int h1 = Murmur3_x86_32.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, bytes.length, 0);\n+    int h2 = Murmur3_x86_32.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, bytes.length, h1);\n+    return (((long) h1) << 32) | (h2 & 0xFFFFFFFFL);\n+  }\n+\n+  @Override\n+  public boolean put(Object item) {\n+    long bitSize = bits.bitSize();\n+    long hash64 = hashObjectToLong(item);\n+    int h1 = (int) (hash64 >> 32);\n+    int h2 = (int) hash64;\n+\n+    boolean bitsChanged = false;\n+    for (int i = 1; i <= numHashFunctions; i++) {\n+      int combinedHash = h1 + (i * h2);\n+      // Flip all the bits if it's negative (guaranteed positive number)\n+      if (combinedHash < 0) {\n+        combinedHash = ~combinedHash;\n+      }\n+      bitsChanged |= bits.set(combinedHash % bitSize);\n+    }\n+    return bitsChanged;\n+  }\n+\n+  @Override\n+  public boolean mightContain(Object item) {\n+    long bitSize = bits.bitSize();\n+    long hash64 = hashObjectToLong(item);\n+    int h1 = (int) (hash64 >> 32);\n+    int h2 = (int) hash64;\n+\n+    for (int i = 1; i <= numHashFunctions; i++) {\n+      int combinedHash = h1 + (i * h2);\n+      // Flip all the bits if it's negative (guaranteed positive number)\n+      if (combinedHash < 0) {\n+        combinedHash = ~combinedHash;\n+      }\n+      if (!bits.get(combinedHash % bitSize)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean isCompatible(BloomFilter other) {\n+    if (other == null) {\n+      return false;\n+    }\n+\n+    if (!(other instanceof DefaultBloomFilter)) {\n+      return false;\n+    }\n+\n+    DefaultBloomFilter that = (DefaultBloomFilter) other;\n+    return this.bitSize() == that.bitSize() && this.numHashFunctions == that.numHashFunctions;\n+  }\n+\n+  @Override\n+  public BloomFilter mergeInPlace(BloomFilter other) {\n+    if (!isCompatible(other)) {\n+      throw new IllegalArgumentException(\"Can't merge incompatible bloom filter\");\n+    }\n+\n+    DefaultBloomFilter that = (DefaultBloomFilter) other;\n+    this.bits.putAll(that.bits);\n+    return this;\n+  }\n+\n+  static final class BitArray {\n+    final long[] data;\n+    long bitCount;\n+\n+    static int safeCast(long numBits) {\n+      long numWords = (long) Math.ceil(numBits / 64.0);\n+      assert numWords <= Integer.MAX_VALUE : \"Can't allocate enough space for \" + numBits + \" bits\";\n+      return (int) numWords;\n+    }\n+\n+    BitArray(long numBits) {\n+      this(new long[safeCast(numBits)]);\n+    }\n+\n+    BitArray(long[] data) {\n+      assert data.length > 0 : \"data length is zero!\";\n+      this.data = data;\n+      long bitCount = 0;\n+      for (long value : data) {\n+        bitCount += Long.bitCount(value);\n+      }\n+      this.bitCount = bitCount;\n+    }\n+\n+    /** Returns true if the bit changed value. */\n+    boolean set(long index) {\n+      if (!get(index)) {\n+        data[(int) (index >>> 6)] |= (1L << index);\n+        bitCount++;\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    boolean get(long index) {\n+      return (data[(int) (index >>> 6)] & (1L << index)) != 0;\n+    }\n+\n+    /** Number of bits */\n+    long bitSize() {\n+      return (long) data.length * Long.SIZE;\n+    }\n+\n+    /** Number of set bits (1s) */\n+    long bitCount() {\n+      return bitCount;\n+    }\n+\n+    BitArray copy() {"
  }],
  "prId": 10883
}]